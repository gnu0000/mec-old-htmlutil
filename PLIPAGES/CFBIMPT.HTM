<HTML>
<HEAD>
<TITLE>cfbimpt.pli</TITLE>
</HEAD>
<BODY>
<H1>cfbimpt.pli</H1>
<PRE>
<HR>
<EM>This page was updated on Wed Dec 18 </EM>
<P>


<A NAME="cfbimpt.pli"></A> /*-----------------------------------------------------------*/
 /*                                                           */
 /*                    FIELD BOOK IMPORT                      */
 /*                                                           */
 /*  THIS PROCESS WILL BE USED FOR BOTH FIELD BOOK SITE TIME  */
 /*  IMPORT AND PROJECT PAYMENT IMPORT PROGRAMS.              */
 /*                                                           */
 /*  THIS PROCESS WILL KEEP A LIST OF THE KEYS TO THE         */
 /*  CONTROLLING ENTITY (VOUCHER/CONTSITE) THAT INCLUDES AN   */
 /*  OVERALL SUCCESS/FAILURE STATUS FOR THE LOAD.  THE PHASE  */
 /*  FLAGS WILL BE UPDATED TO REFLECT THE RESULTS OF THE      */
 /*  LOAD.                                                    */
 /*                                                           */
 /*-----------------------------------------------------------*/
 /*                                                           */
 /*  UPDATE :  CJB  4/3/95                                    */
 /*            ADDED PROCESSING FOR SCHDCNTL FILE.            */
 /*                                                           */
 /*         :  PCGW 1/3/96                                    */
 /*            ADDED PROCESSING FOR CONTSITE FILE.            */
 /*                                                           */
 /*-----------------------------------------------------------*/
<A NAME="CFBIMPT"></A> CFBIMPT:  PROC OPTIONS (MAIN);

   %INCLUDE BENVSTP;
   %INIT_TYPE = 'DEVELOPMENT';
   %INCLUDE BTCSTUP;

   SHELL$MODULE_NAME    = '<A HREF="cfbimpt.htm#CFBIMPT">CFBIMPT</A>';
   SHELL$MODULE_SEGMENT = 'SETUP';

   ITRC = ITSET ('LOCK', 'RETURN');
   ITRC = ITSET ('TNF',  'FATAL');

   %INCLUDE ERRORDET;
   %INCLUDE PROJCONT;
   %INCLUDE VOUCHER;
   %INCLUDE CONTSITE;

   %DCL DEBUGGER CHARACTER;
   %DEBUGGER = 'OFF';

   DCL OUTPUTE                      FILE PRINT,
       IMPORT                       FILE,
       (IMPTDEF_PTR,ERROR_LIST_TOP,
        TEMP_S, TEMP_P, ERR_PTR)    POINTER,
       STATUS                       FIXED BIN (15),
       (MESSAGE,RECORD_ID,
        KEY_VALUE,IMPTDEF_FILENAME) CHAR (512) VARYING,
       TABLE                        CHAR (8),
       CONTID                       CHAR (15),
       PCN                          CHAR (13),
       VCH                          CHAR (4),
       DATE                         BUILTIN,
       FATAL_ERROR_MESSAGE          CHAR (80),
       (ERR_PAGENO,ERR_LINENO)      FIXED BIN (15),
       (SITE_DATA,PROJECT_DATA,
        FIRST_PAGE,
        CONTINUE,ERROR_FOUND)       BIT (1);

   DCL (E,E_TOP,E_END,S,P)          POINTER;

   DCL 1 ENTITY_NODE    BASED,
         2 CONTID       CHAR (15),
         2 PROJECT_PTR  POINTER,
         2 SITE_PTR     POINTER,
         2 NEXT_PTR     POINTER;

   DCL 1 SITE_NODE      BASED,
         2 SITENUM      CHAR (2),
         2 SUCCESS      BIT (1),
         2 FLIP_FLAGS   BIT (1),
         2 NEXT_PTR     POINTER;

   DCL 1 PROJECT_NODE   BASED,
         2 PCN          CHAR (13),
         2 VCH          CHAR (4),
         2 SUCCESS      BIT (1),
         2 FLIP_FLAGS   BIT (1),
         2 NEXT_PTR     POINTER;

   DCL 1 ERROR_MESSAGE_NODE  BASED,
         2 MESSAGE           CHAR (512) VARYING,
         2 NEXT_PTR          POINTER;

   E_TOP          = NULL;
   E_END          = NULL;
   IMPTDEF_PTR    = NULL;
   ERROR_LIST_TOP = NULL;
   FIRST_PAGE  = '1'B;
   ERROR_FOUND = '0'B;
   STATUS      = 0;
   MESSAGE     = '';
   PAGENO      = 0;

   IMPTDEF_FILENAME = 'IMPTDEF';

   /*--- INITIALIZES THE ENVIRONMENT ---*/
   CALL INITIALIZE_CSV_IMPORT (IMPTDEF_FILENAME,IMPTDEF_PTR,
                               STATUS,ERROR_LIST_TOP);

   IF STATUS ^= 0
      THEN DO;
        FATAL_ERROR_MESSAGE =
             ERROR_LIST_TOP-&gtERROR_MESSAGE_NODE.MESSAGE;
        CALL FATAL_ERROR ('PROGRAM',FATAL_ERROR_MESSAGE);
      END;

   /*--- OPEN ERROR LOG AND GENERATE HEADER ---*/
   %IF PREPROC$OPSYS = 'VMS'
       %THEN %DO;
          OPEN FILE (OUTPUTE)
               ENV  (APPEND)
               PAGESIZE (66);
       %END;
       %ELSE %DO;
          OPEN FILE (OUTPUTE)
               PAGESIZE (66);
       %END;

   ITRC = ITOPEN('PROJCONT',ADDR(PROJCONT_RECORD),'READ',' ',' ',' ');

   OPEN FILE (IMPORT)
        RECORD SEQUENTIAL INPUT;

   CALL ERROR_HEADER;

   CONTINUE = '1'B;

   DO WHILE (CONTINUE);

      /*--- PROCESS CSV RECORDS ---*/
      CALL IMPORT_NEXT_CSV_RECORD (IMPORT,IMPTDEF_PTR,RECORD_ID,TABLE,
                                   KEY_VALUE,STATUS,ERROR_LIST_TOP);

      SELECT;

        WHEN (STATUS = 0 | STATUS = 10)
          DO;
           CALL UPDATE_ENTITY_NODE;
           IF STATUS = 10
              THEN CALL WRITE_MESSAGE;
           CONTINUE = '1'B;
          END;

        WHEN (STATUS = 4)
          DO;

           /*--- FREES IMPORT DATA STRUCTURE ---*/
           CALL END_CSV_IMPORT (IMPTDEF_PTR,STATUS,ERROR_LIST_TOP);

           IF STATUS ^= 0
              THEN DO;
                FATAL_ERROR_MESSAGE =
                    ERROR_LIST_TOP-&gtERROR_MESSAGE_NODE.MESSAGE;
                CALL FATAL_ERROR ('PROGRAM',FATAL_ERROR_MESSAGE);
              END;

           CALL UPDATE_PHASE_FLAGS;
           CONTINUE = '0'B;
          END;

        WHEN (STATUS = 2 | STATUS = 6)
          DO;
           CONTINUE = '1'B;
          END;

        WHEN (STATUS = 8)
          DO;
           CALL UPDATE_ENTITY_NODE;
           CALL WRITE_MESSAGE;
           CONTINUE = '1'B;
          END;

        WHEN (STATUS = 12 | STATUS = 16)
          DO;
           FATAL_ERROR_MESSAGE =
                ERROR_LIST_TOP-&gtERROR_MESSAGE_NODE.MESSAGE;
           CALL FATAL_ERROR ('PROGRAM',FATAL_ERROR_MESSAGE);
          END;

        OTHERWISE;
      END;

      /*--- FREE MESSAGE LIST ---*/
      DO WHILE (ERROR_LIST_TOP ^= NULL);
         ERR_PTR = ERROR_LIST_TOP-&gtERROR_MESSAGE_NODE.NEXT_PTR;
         FREE ERROR_LIST_TOP-&gtERROR_MESSAGE_NODE;
         ERROR_LIST_TOP = ERR_PTR;
      END;

   END;


   CALL FREE_LISTS;

   IF ^ERROR_FOUND
      THEN CALL ERROR_DETAIL
           ('*****  NO ERRORS FOUND DURING PROCESSING  *****','N');

   ITRC = ITCLOSE ('PROJCONT',' ');
   CLOSE FILE (OUTPUTE);

 /*-----------------------------------------------------------*/
 /*                       UPDATE_ENTITY_NODE                  */
 /*-----------------------------------------------------------*/
<A NAME="UPDATE_ENTITY_NODE"></A> UPDATE_ENTITY_NODE: PROC;

    DCL SAVE_SEGMENT          CHAR (31),
        FOUND                 BIT (1);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'UPDATE_ENTITY_NODE';

    SITE_DATA    = '0'B;
    PROJECT_DATA = '0'B;

    CALL ACCESS_CONTID;

    /*--- SEE IF CONTRACT IS ALREADY ON LIST ---*/
    FOUND = '0'B;
    E     = E_TOP;
    DO WHILE (E ^= NULL &amp ^FOUND);

      IF E-&gtENTITY_NODE.CONTID = CONTID
         THEN FOUND = '1'B;
         ELSE E = E-&gtENTITY_NODE.NEXT_PTR;

    END;

    /*--- IF CONTRACT IS NOT ON THE LIST, ADD IT ---*/
    IF ^FOUND
       THEN DO;

         ALLOCATE ENTITY_NODE SET (E);
         E-&gtENTITY_NODE.CONTID      = CONTID;
         E-&gtENTITY_NODE.PROJECT_PTR = NULL;
         E-&gtENTITY_NODE.SITE_PTR    = NULL;
         E-&gtENTITY_NODE.NEXT_PTR    = NULL;

         IF E_TOP = NULL
            THEN E_TOP = E;
            ELSE E_END-&gtENTITY_NODE.NEXT_PTR = E;

         E_END = E;

       END;

    /*--- CONTRACT IS NOW ON LIST, UPDATE OTHER LISTS ---*/

    IF SITE_DATA
       THEN CALL PROCESS_SITES;

    IF PROJECT_DATA
       THEN CALL PROCESS_PROJECTS;

    /*--------------------------------------------------------*/
    /*                   PROCESS_SITES                        */
    /* ADDED CONTSITE TO LIST IN IF STATEMENTS TO SET THE     */
    /* FLIPFLAG TO TRUE.  PCGW 1/3/95                         */ 
    /*--------------------------------------------------------*/
<A NAME="PROCESS_SITES"></A>    PROCESS_SITES: PROC;

    DCL SAVE_SEGMENT                   CHAR (31),
        SITENUM                        CHAR (2),
        LAST_SITE                      POINTER,
        (OK,SITE_FOUND)                BIT (1);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'PROCESS_SITES';

    /*--- FOR FILES THAT DO NOT CONTAIN SITE INFO, USE 00 SITE ---*/
    IF (RECORD_ID = 'CONTMOD' | RECORD_ID = 'CONTCOM' |
        RECORD_ID = 'QTYCHG'  | RECORD_ID = 'PROJITEM')       
       THEN SITENUM = '00';
       ELSE SITENUM = SUBSTR(KEY_VALUE,16,2);

    TEMP_S = E-&gtENTITY_NODE.SITE_PTR;

    /*--- SEE IF SITE IS ALREADY ON LIST ---*/
    SITE_FOUND = '0'B;
    DO WHILE (TEMP_S ^= NULL &amp ^SITE_FOUND);
       IF TEMP_S-&gtSITE_NODE.SITENUM = SITENUM
          THEN SITE_FOUND = '1'B;
          ELSE DO;
            LAST_SITE = TEMP_S;
            TEMP_S = TEMP_S-&gtSITE_NODE.NEXT_PTR;
          END;
    END;

    IF ^SITE_FOUND
       THEN DO;

         ALLOCATE SITE_NODE SET (S);
         S-&gtSITE_NODE.SITENUM    = SITENUM;
         S-&gtSITE_NODE.NEXT_PTR   = NULL;

         /*--- 0 = SUCCESSFUL, 4 = EOF ---*/

         IF STATUS = 0 | STATUS = 4
            THEN S-&gtSITE_NODE.SUCCESS = '1'B;
            ELSE S-&gtSITE_NODE.SUCCESS = '0'B;

         IF (RECORD_ID = 'SITETIME' | RECORD_ID = 'CONTSCHD' |
             RECORD_ID = 'TIMECHNG' | RECORD_ID = 'SCHDCNTL' |
             RECORD_ID = 'CONTSITE' )
            THEN S-&gtSITE_NODE.FLIP_FLAGS = '1'B;
            ELSE S-&gtSITE_NODE.FLIP_FLAGS = '0'B;

         IF E-&gtENTITY_NODE.SITE_PTR = NULL
            THEN E-&gtENTITY_NODE.SITE_PTR = S;
            ELSE LAST_SITE-&gtSITE_NODE.NEXT_PTR = S;

       END;
       ELSE DO;

         /*--- 0 = SUCCESSFUL, 4 = EOF ---*/
         IF STATUS = 0 | STATUS = 4
            THEN OK = '1'B;
            ELSE OK = '0'B;

         /*--- STATUS MUST BE 'ANDED' BECAUSE THERE COULD ---*/
         /*--- BE SEVERAL SITE FILES THAT HAVE CORRECT    ---*/
         /*--- DATA BUT ONE WITH INCORRECT DATA SO THE    ---*/
         /*--- FLAGS FOR THE SITE AS A WHOLE SHOULD       ---*/
         /*--- INDICATE THERE WAS AN ERROR                ---*/

         S-&gtSITE_NODE.SUCCESS = S-&gtSITE_NODE.SUCCESS &amp OK;

         IF (RECORD_ID = 'SITETIME' | RECORD_ID = 'CONTSCHD' |
             RECORD_ID = 'TIMECHNG' | RECORD_ID = 'SCHDCNTL' |
             RECORD_ID = 'CONTSITE' )
            THEN S-&gtSITE_NODE.FLIP_FLAGS = '1'B;

       END;

       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END PROCESS_SITES;

    /*--------------------------------------------------------*/
    /*                   PROCESS_PROJECTS                     */
    /*--------------------------------------------------------*/
    PROCESS_PROJECTS: PROC;

    DCL SAVE_SEGMENT                   CHAR (31),
        LAST_PROJECT                   POINTER,
        (OK,PROJECT_FOUND)             BIT (1);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'PROCESS_PROJECTS';

    PCN = SUBSTR(KEY_VALUE,1,13);
    VCH = SUBSTR(KEY_VALUE,14,4);

    TEMP_P = E-&gtENTITY_NODE.PROJECT_PTR;

    /*--- SEE IF PROJECT/VCH COMBO IS ALREADY ON LIST ---*/
    PROJECT_FOUND = '0'B;
    DO WHILE (TEMP_P ^= NULL &amp ^PROJECT_FOUND);
       IF TEMP_P-&gtPROJECT_NODE.PCN = PCN &amp
          TEMP_P-&gtPROJECT_NODE.VCH = VCH
          THEN PROJECT_FOUND = '1'B;
          ELSE DO;
            LAST_PROJECT = TEMP_P;
            TEMP_P = TEMP_P-&gtPROJECT_NODE.NEXT_PTR;
          END;
    END;

    IF ^PROJECT_FOUND
       THEN DO;

         ALLOCATE PROJECT_NODE SET (P);
         P-&gtPROJECT_NODE.PCN  = PCN;
         P-&gtPROJECT_NODE.VCH  = VCH;
         P-&gtPROJECT_NODE.NEXT_PTR = NULL;

         /*--- 0 = SUCCESSFUL, 4 = EOF ---*/
         IF STATUS = 0 | STATUS = 4
            THEN P-&gtPROJECT_NODE.SUCCESS = '1'B;
            ELSE P-&gtPROJECT_NODE.SUCCESS = '0'B;

         IF (RECORD_ID = 'VOUCHER' | RECORD_ID = 'MATALW' |
             RECORD_ID = 'PARTPAY')
            THEN P-&gtPROJECT_NODE.FLIP_FLAGS = '1'B;
            ELSE P-&gtPROJECT_NODE.FLIP_FLAGS = '0'B;

         IF E-&gtENTITY_NODE.PROJECT_PTR = NULL
            THEN E-&gtENTITY_NODE.PROJECT_PTR = P;
            ELSE LAST_PROJECT-&gtPROJECT_NODE.NEXT_PTR = P;

       END;
       ELSE DO;

         /*--- 0 = SUCCESSFUL, 4 = EOF ---*/
         IF STATUS = 0 | STATUS = 4
            THEN OK = '1'B;
            ELSE OK = '0'B;

         /*--- STATUS MUST BE 'ANDED' BECAUSE THERE COULD ---*/
         /*--- BE SEVERAL PROJECT FILES THAT HAVE CORRECT ---*/
         /*--- DATA BUT ONE WITH INCORRECT DATA SO THE    ---*/
         /*--- FLAGS FOR THE PROJECT AS A WHOLE SHOULD    ---*/
         /*--- INDICATE THERE WAS AN ERROR                ---*/

         P-&gtPROJECT_NODE.SUCCESS = P-&gtPROJECT_NODE.SUCCESS &amp OK;

         IF (RECORD_ID = 'VOUCHER' | RECORD_ID = 'MATALW' |
             RECORD_ID = 'PARTPAY')
            THEN P-&gtPROJECT_NODE.FLIP_FLAGS = '1'B;

       END;

       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END PROCESS_PROJECTS;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END UPDATE_ENTITY_NODE;

 /*-----------------------------------------------------------*/
 /*                       WRITE_MESSAGE                       */
<A NAME="WRITE_MESSAGE"></A> /*-----------------------------------------------------------*/
 WRITE_MESSAGE:      PROC;

    DCL SAVE_SEGMENT        CHAR (31),
        COMPLETE_MSG        CHAR (512) VARYING,
        PROJECT_STRING      CHAR (13),
        ERROR_PTR           POINTER;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'WRITE_MESSAGE';


    IF (RECORD_ID = 'MATALW'  | RECORD_ID = 'PARTPAY' |
        RECORD_ID = 'VOUCHER' | RECORD_ID = 'QTYCHG' |
        RECORD_ID = 'PROJITEM')
        THEN PROJECT_STRING = SUBSTR(KEY_VALUE,1,13);
        ELSE PROJECT_STRING = ' ';

    /*--- BECAUSE THE UPDATE_ENTITY_NODE ROUTINE IS CALLED ---*/
    /*--- PRIOR TO THIS ROUTINE, THE CURRENT CONTID HAS    ---*/
    /*--- ALREADY BEEN ACCESSED.                           ---*/

    ERROR_PTR = ERROR_LIST_TOP;

    DO WHILE (ERROR_PTR ^= NULL);

       IF ^ERROR_FOUND
          THEN ERROR_FOUND = '1'B;

       COMPLETE_MSG = TRIM(ERROR_PTR-&gtERROR_MESSAGE_NODE.MESSAGE)  ||
                      ' (CONTRACT=' || TRIM(CONTID) || ' PROJECT=' ||
                      TRIM(PROJECT_STRING) || ')';

       CALL ERROR_DETAIL(COMPLETE_MSG,'E');

       ERROR_PTR = ERROR_PTR-&gtERROR_MESSAGE_NODE.NEXT_PTR;
    END;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END WRITE_MESSAGE;

 /*-----------------------------------------------------------*/
<A NAME="UPDATE_PHASE_FLAGS"></A> /*                    UPDATE_PHASE_FLAGS                     */
 /*-----------------------------------------------------------*/
 UPDATE_PHASE_FLAGS: PROC;

    DCL SAVE_SEGMENT        CHAR (31);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'UPDATE_PHASE_FLAGS';

    /* CALL DUMP_LISTS; */

    ITRC = ITOPEN('VOUCHER',ADDR(VOUCHER_RECORD),'WRITE',' ',' ',' ');
    ITRC = ITOPEN('CONTSITE',ADDR(CONTSITE_RECORD),'WRITE',' ',' ',' ');

    E = E_TOP;

    DO WHILE (E ^= NULL);

       IF E-&gtENTITY_NODE.SITE_PTR ^= NULL
          THEN CALL UPDATE_CONTSITE;

       IF E-&gtENTITY_NODE.PROJECT_PTR ^= NULL
          THEN CALL UPDATE_VOUCHER;

       E = E-&gtENTITY_NODE.NEXT_PTR;
    END;

    ITRC = ITCLOSE ('VOUCHER',' ');
    ITRC = ITCLOSE ('CONTSITE',' ');

<A NAME="UPDATE_VOUCHER"></A>    /*--------------------------------------------------------*/
    /*                 UPDATE_VOUCHER                         */
    /*--------------------------------------------------------*/
    UPDATE_VOUCHER: PROC;

       DCL SAVE_SEGMENT        CHAR (31),
           VOUCHER_FOUND       BIT (1);

       SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
       SHELL$MODULE_SEGMENT = 'UPDATE_VOUCHER';

       TEMP_P = E-&gtENTITY_NODE.PROJECT_PTR;

       DO WHILE (TEMP_P ^= NULL);

          VOUCHER_FOUND = '1'B;
          VOUCHER_KEY   = TEMP_P-&gtPROJECT_NODE.PCN ||
                          TEMP_P-&gtPROJECT_NODE.VCH;

          ITRC = ITREAD('VOUCHER',VOUCHER_KEY,'0','');
          IF ITRC=8
             THEN VOUCHER_FOUND = '0'B;

          IF ^VOUCHER_FOUND
              THEN CALL FATAL_ERROR ('PROGRAM','NO ' ||
               'VOUCHER RECORD FOR PCN ' ||
               TEMP_P-&gtPROJECT_NODE.PCN ||
               ' VOUCHER ' || TEMP_P-&gtPROJECT_NODE.VCH);

          IF TEMP_P -&gt PROJECT_NODE.SUCCESS &amp
             TEMP_P -&gt PROJECT_NODE.FLIP_FLAGS
             THEN DO;
               VOUCHER_RECORD.VOFLOAD = 'C';
               VOUCHER_RECORD.VOFEDIT = ' ';
               VOUCHER_RECORD.VOFICALC= ' ';
               VOUCHER_RECORD.VOFCALC = ' ';
               VOUCHER_RECORD.VOFVRPT = ' ';
               VOUCHER_RECORD.VOFCRPT = ' ';
             END;

          IF ^TEMP_P -&gt PROJECT_NODE.SUCCESS
             THEN DO;
               VOUCHER_RECORD.VOFLOAD = 'E';
               VOUCHER_RECORD.VOFEDIT = 'P';
               VOUCHER_RECORD.VOFICALC= 'P';
               VOUCHER_RECORD.VOFCALC = 'P';
               VOUCHER_RECORD.VOFVRPT = 'P';
               VOUCHER_RECORD.VOFCRPT = 'P';
             END;

          VOUCHER_KEY = VOUCHER_RECORD.PCN ||
                        VOUCHER_RECORD.VOUCHER;

          ITRC = ITWRITE( 'VOUCHER',' ');

          TEMP_P = TEMP_P -&gtPROJECT_NODE.NEXT_PTR;

       END;

       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END UPDATE_VOUCHER;
<A NAME="UPDATE_CONTSITE"></A>
    /*--------------------------------------------------------*/
    /*                 UPDATE_CONTSITE                        */
    /*--------------------------------------------------------*/
    UPDATE_CONTSITE: PROC;

       DCL SAVE_SEGMENT        CHAR (31),
           CONTSITE_FOUND      BIT (1);

       SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
       SHELL$MODULE_SEGMENT = 'UPDATE_CONTSITE';

       TEMP_S = E-&gtENTITY_NODE.SITE_PTR;

       DO WHILE (TEMP_S ^= NULL);

          CONTSITE_FOUND = '1'B;
          CONTSITE_KEY   = E-&gtENTITY_NODE.CONTID ||
                           TEMP_S-&gtSITE_NODE.SITENUM;
          ITRC = ITREAD('CONTSITE',CONTSITE_KEY,'0','');
          IF ITRC=8
             THEN CONTSITE_FOUND = '0'B;

          IF ^CONTSITE_FOUND
             THEN CALL FATAL_ERROR ('PROGRAM','NO CONTSITE RECORD'||
                  ' FOR CONTRACT ' || E-&gtENTITY_NODE.CONTID || ' SITE'
                  || ' ' || TEMP_S-&gtSITE_NODE.SITENUM);

          IF TEMP_S -&gt SITE_NODE.SUCCESS &amp
             TEMP_S -&gt SITE_NODE.FLIP_FLAGS
             THEN DO;
               CONTSITE_RECORD.PSFLOAD = 'C';
               CONTSITE_RECORD.PSFEDIT = ' ';
               CONTSITE_RECORD.PSFCALC = ' ';
               CONTSITE_RECORD.PSFRPT  = ' ';
             END;

          IF ^TEMP_S -&gt SITE_NODE.SUCCESS
             THEN DO;
               CONTSITE_RECORD.PSFLOAD = 'E';
               CONTSITE_RECORD.PSFEDIT = 'P';
               CONTSITE_RECORD.PSFCALC = 'P';
               CONTSITE_RECORD.PSFRPT  = 'P';
             END;

          ITRC = ITWRITE( 'CONTSITE',' ');

          TEMP_S = TEMP_S -&gtSITE_NODE.NEXT_PTR;
       END;

       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END UPDATE_CONTSITE;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END UPDATE_PHASE_FLAGS;
<A NAME="ACCESS_CONTID"></A>
 /*-----------------------------------------------------------*/
 /*                       ACCESS_CONTID                       */
 /*  ADDED CONTSITE TO LIST OF VALID FILES.   PCGW 1/3/95     */
 /*-----------------------------------------------------------*/
 ACCESS_CONTID: PROC;

    DCL SAVE_SEGMENT          CHAR (31);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'ACCESS_CONTID';

    /*--- ACCESS CONTRACT ID ---*/
    SELECT;

      WHEN (RECORD_ID = 'CONTSCHD' | RECORD_ID = 'SITETIME' |
            RECORD_ID = 'TIMECHNG' | RECORD_ID = 'CONTCOM' |
            RECORD_ID = 'CONTMOD'  | RECORD_ID = 'SCHDCNTL' |
            RECORD_ID = 'CONTSITE')
        DO;
         CONTID = SUBSTR(KEY_VALUE,1,15);
         SITE_DATA = '1'B;
        END;

      WHEN (RECORD_ID = 'MATALW'  | RECORD_ID = 'PARTPAY' |
            RECORD_ID = 'VOUCHER')
        DO;
         CALL GET_CONTRACT_ID;
         PROJECT_DATA = '1'B;
        END;

      /*--- FOR QTYCHG AND PROJITEM THE 00 SITE FLAGS ---*/
      /*--- WILL BE UPDATED SO TO DO THIS, THE SITE   ---*/
      /*--- DATA FLAG MUST BE SET EVEN THOUGH THESE   ---*/
      /*--- FILES ARE NOT CONTRACT LEVEL FILES.       ---*/

      WHEN (RECORD_ID = 'QTYCHG'  | RECORD_ID = 'PROJITEM')
        DO;
         CALL GET_CONTRACT_ID;
         SITE_DATA = '1'B;
        END;

      OTHERWISE
        DO;
         CALL FATAL_ERROR ('PROGRAM','INVALID RECORD ID SPECIFIED');
<A NAME="GET_CONTRACT_ID"></A>        END;
    END;

    /*--------------------------------------------------------*/
    /*                   GET_CONTRACT_ID                      */
    /*--------------------------------------------------------*/
    GET_CONTRACT_ID: PROC;

    DCL SAVE_SEGMENT        CHAR (31),
        PROJCONT_FOUND      BIT (1);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'GET_CONTRACT_ID';

    PCN = SUBSTR(KEY_VALUE,1,13);

    PROJCONT_FOUND = '1'B;
    ITRC = ITREAD('PROJCONT',PCN,'0','GE');
    IF ITRC=8
       THEN PROJCONT_FOUND = '0'B;

    IF PROJCONT_FOUND &amp PROJCONT_RECORD.PCN = PCN
       THEN CONTID = PROJCONT_RECORD.CONTID;
       ELSE CONTID = ' ';

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END GET_CONTRACT_ID;

<A NAME="ERROR_HEADER"></A>    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END ACCESS_CONTID;

 /*-----------------------------------------------------------*/
 /*                       ERROR HEADER                        */
 /*-----------------------------------------------------------*/
 ERROR_HEADER:  PROC;

    DCL SAVE_SEGMENT        CHAR (31);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'ERROR_HEADER';

    /*--- THE FOLLOWING IS CODE THAT WILL BE IMPLEMENTED IN ---*/
    /*--- VERSION 2 OF THE FIELD BOOK                       ---*/
    /*
    ERR_PAGENO = 1;

    PUT FILE (OUTPUTE) PAGE;

    RTFCA.PAGEPTR = ADDR(ERR_PAGENO);
    RTFCA.PAGESIZE = INSTOPT_PAGESIZE_OUTPUT12;
    CALL RTFEXEC(OUTPUTE,'DDNAME=CXFLDBK' ||
                 'PAGESIZE=' ||
                 TRIM(CHAR(INSTOPT_PAGESIZE_OUTPUT12)));
     */

    ERR_LINENO = 4;

    PAGENO = PAGENO + 1;

    IF FIRST_PAGE
       THEN FIRST_PAGE = '0'B;
       ELSE PUT FILE (OUTPUTE) PAGE;

    PUT FILE (OUTPUTE) SKIP (2) EDIT
       ('CONSTRUCTION FIELD BOOK','DATE : ',
        SUBSTR(DATE,3,2) || '/' ||
        SUBSTR(DATE,5,2) || '/' ||
        SUBSTR(DATE,1,2))
       (COL(55),A,COL(115),A,COL(122),A);

    PUT FILE (OUTPUTE) EDIT
       ('PROCESSING LOG','PAGE : ',TRIM(CHAR(PAGENO)))
       (COL(59),A,COL(115),A,COL(122),A);

<A NAME="FREE_LISTS"></A>    PUT FILE (OUTPUTE) SKIP EDIT
       (COPY ('-',132))
       (COL(1),A);

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END ERROR_HEADER;

 /*-----------------------------------------------------------*/
 /*                       FREE_LISTS                          */
 /*-----------------------------------------------------------*/
 FREE_LISTS: PROC;

    DCL SAVE_SEGMENT        CHAR (31),
        (S,P,S_TOP,P_TOP)   POINTER;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'FREE_LISTS';

    DO WHILE (E_TOP ^= NULL);
       E = E_TOP-&gtENTITY_NODE.NEXT_PTR;

       /*--- FREE SITE LIST ---*/
       S_TOP = E_TOP-&gtENTITY_NODE.SITE_PTR;
       DO WHILE (S_TOP ^= NULL);
          S = S_TOP-&gtSITE_NODE.NEXT_PTR;
          FREE S_TOP-&gtSITE_NODE;
          S_TOP = S;
       END;

       /*--- FREE PROJECT LIST ---*/
       P_TOP = E_TOP-&gtENTITY_NODE.PROJECT_PTR;
       DO WHILE (P_TOP ^= NULL);
          P = P_TOP-&gtPROJECT_NODE.NEXT_PTR;
          FREE P_TOP-&gtPROJECT_NODE;
          P_TOP = P;
       END;
<A NAME="DUMP_LISTS"></A>
       FREE E_TOP-&gtENTITY_NODE;
       E_TOP = E;
    END;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END FREE_LISTS;

 /*-----------------------------------------------------------*/
 /*                       DUMP_LISTS                          */
 /*-----------------------------------------------------------*/
 DUMP_LISTS: PROC;

    DCL SAVE_SEGMENT        CHAR (31),
        STAT                CHAR (1),
        FLAG                CHAR (20),
        DUMP                FILE;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'DUMP_LISTS';

   OPEN FILE (DUMP)
        STREAM OUTPUT;

   PUT FILE(DUMP) SKIP EDIT ('ENTITY LIST') (A);

   IF E_TOP = NULL
      THEN DO;
        PUT FILE(DUMP) SKIP(2) EDIT ('ENTITY LIST IS EMPTY')
                                    (COL(1),A);
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

    E = E_TOP;
    DO WHILE (E ^= NULL);

      PUT FILE(DUMP) SKIP EDIT (E-&gtENTITY_NODE.CONTID) (COL(5),A);

      IF E-&gtENTITY_NODE.PROJECT_PTR = NULL
         THEN PUT FILE(DUMP) SKIP EDIT ('NO PROJECTS') (COL(5),A);

      IF E-&gtENTITY_NODE.SITE_PTR = NULL
         THEN PUT FILE(DUMP) SKIP EDIT ('NO SITES') (COL(5),A);

      /*--- DUMP PROJECT INFO ---*/
      IF E-&gtENTITY_NODE.PROJECT_PTR ^= NULL
         THEN DO;
           TEMP_P = E-&gtENTITY_NODE.PROJECT_PTR;

           DO WHILE (TEMP_P ^= NULL);

              IF TEMP_P-&gtPROJECT_NODE.SUCCESS
                 THEN STAT = 'Y';
                 ELSE STAT = 'N';

              IF TEMP_P-&gtPROJECT_NODE.FLIP_FLAGS
                 THEN FLAG = 'FLIP FLAGS';
                 ELSE FLAG = 'DO NOT FLIP FLAGS';

              PUT FILE(DUMP) SKIP EDIT
                 (TEMP_P-&gtPROJECT_NODE.PCN,
                  TEMP_P-&gtPROJECT_NODE.VCH,
                  STAT,
                  FLAG)
                 (COL(10),A,COL(25),A,COL(32),A,COL(40),A);

              TEMP_P = TEMP_P -&gtPROJECT_NODE.NEXT_PTR;
           END;
         END;

      /*--- DUMP SITE INFO ---*/
      IF E-&gtENTITY_NODE.SITE_PTR ^= NULL
         THEN DO;
           TEMP_S = E-&gtENTITY_NODE.SITE_PTR;

           DO WHILE (TEMP_S ^= NULL);

              IF TEMP_S-&gtSITE_NODE.SUCCESS
                 THEN STAT = 'Y';
                 ELSE STAT = 'N';

              PUT FILE(DUMP) SKIP EDIT
                 (TEMP_S-&gtSITE_NODE.SITENUM,
                  STAT)
                 (COL(10),A,COL(25),A);

              TEMP_S = TEMP_S -&gtSITE_NODE.NEXT_PTR;
           END;
         END;

      E = E-&gtENTITY_NODE.NEXT_PTR;
    END;

    CLOSE FILE (DUMP);

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_LISTS;

 /*------------------------------------------------------------------*/
 /*                      INITIALIZE_CSV_IMPORT                       */
 /*                                                                  */
 /* THIS PROCEDURE LOADS THE IMPORT DEFINITION FROM THE IMPORT       */
 /* DEFINITION FILE, NAMED IDF, INTO AN IMPORT DEFINITION DATA       */
 /* STRUCTURE IN MEMORY, NAMED IDDS.  IF PROCESSING IS SUCCESSFULL,  */
 /* THE PROCEDURE WILL OPEN ALL DATABASE TABLES INTO WHICH DATA IS TO*/
 /* BE IMPORTED AND ALL DATABASE TABLES THAT ARE USED FOR REFERENCE  */
 /* LOOKUPS.                                                         */
 /* PARAMETERS:                                                      */
 /*      IDF_NAME - CHAR(*) VARYING STRING CONTAINING THE NAME OF    */
 /*                 IMPORT DEFINITION FILE.                          */
 /*                                                                  */
 /*      IDSPTR   - POINTER TO THE IMPORT DEFINITION DATA STRUCTURE. */
 /*                                                                  */
 /*      STATUS   - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0 - SUCCESSFUL                                   */
 /*                12 - FAILED.                                      */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /* DECLARATIONS NEEDED BY THIS PROCEDURES                           */
 /* IDFSTRUCT.PLI              - IDF DATA STRUCTURES                 */
 /* DUMP_IDF_STRUCTURES.PLI    - DEBUGGING PROCEDURES                */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/11/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /* RTD 3/1/95 - ADDED NEW YYMMDDHHMM OUTPUT FORMAT TO DATETIME     */
 /*              VERIFICATION PROCEDURE.CHANGED GET_DATETIME_FORMAT */
 /*              IN PARSER TO SUPPORT NEW FORMAT.                   */
 /*              VERIFY_DATETIME_VALUE HAS ALSO BEEN CHANGED.       */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 INITIALIZE_CSV_IMPORT: PROC (IDF_NAME,IDSPTR,STATUS,ERRLST_TOP);

   DCL IDF_NAME          CHAR (*) VARYING,
       IDSPTR            POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       IDF               FILE,
       IDF_EOF           BIT (1) INIT ('0'B),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'INITIALIZE_CSV_IMPORT';

   %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ON ENDFILE (IDF) IDF_EOF = '1'B;
   ON UNDEFINEDFILE (IDF) IDF_EOF = '1'B;
   STATUS = 0;

   /*----- OPEN THE FLAT FILE FOR READ       -----*/

   %IF PREPROC$OPSYS= 'VMS'
        %THEN %DO;
          OPEN FILE (IDF) RECORD SEQUENTIAL INPUT
          TITLE (IDF_NAME)
          ENVIRONMENT(NO_SHARE);
        %END;
        %ELSE %DO;
          OPEN FILE (IDF) RECORD SEQUENTIAL INPUT
          TITLE (IDF_NAME);
        %END;

   IF IDF_EOF
      THEN DO;
       STATUS = 12;
       ERRMSG = 'THE IMPORT DEFINITION FILE WAS NOT FOUND';
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;
      ELSE DO;

       ALLOCATE IMPORT_DEFINITION SET (IDSPTR);
       IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR       = NULL;
       IDSPTR-&gtIMPORT_DEFINITION.LAST_RECORD_NODE_PTR  = NULL;

       IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR  =
          GET_RECORD_FROM_IDF
                     (IDF,
                      IDSPTR-&gtIMPORT_DEFINITION.LAST_RECORD_NODE_PTR,
                      STATUS,
                      ERRLST_TOP);
       IF IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR = NULL
          THEN DO;
           STATUS = 12;
           ERRMSG = 'NO RECORD DEFINITION WAS FOUND IN THE IMPORT' ||
                   ' DEFINITION FILE.';
           CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                            ERRMSG    );
          END;
          ELSE
           CALL OPEN_IMPORT_FILES
                          (IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR,
                           STATUS,
                           ERRLST_TOP                            );

      END; /* IF NOT IDF_EOF */

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;


 /*------------------------------------------------------------------*/
 /*                      GET_RECORD_FROM_IDF                         */
 /*                                                                  */
 /* THIS PROCEDURE READS ALL OF THE IMPORT DEFINITIONS FOR A RECORD  */
 /* AND INITIALIZES EACH RECORD NODE.  AS PART OF THE PROCESS, IT    */
 /* CALLS PROCEDURES TO INITIALIZE INIT NODES AND FIELD NODES.       */
 /* THE PROCEDURE RETURNS A POINTER TO THE FIRST RECORD NODE AND SETS*/
 /* THE LAST IMPORT DEFINITION LAST RECORD POINTER.                  */
 /*                                                                  */
 /* THIS PROCEDURE IS RECURSIVE AND TERMINATES IF EITHER AN ERROR OR */
 /* THE END OF THE IMPORT FILE IS ENCOUNTERED.                       */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   IDF          - THE IMPORT DEFINITION FILE HANDLE.              */
 /*                                                                  */
 /*   LAST_IDR_PTR - POINTER TO THE LAST IMPORT DEFINITION RECORD    */
 /*                  STRUCTURE.                                      */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
<A NAME="GET_RECORD_FROM_IDF"></A> /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/11/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_RECORD_FROM_IDF: PROC (IDF, LAST_IDR_PTR, STATUS, ERRLST_TOP)
                           RETURNS (POINTER);
   DCL IDF               FILE,
       LAST_IDR_PTR      POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       RECORD_ID         CHAR (80) VARYING,
       IGNORE            BIT (1) INIT ('0'B),
       ERROR             BIT (1) INIT ('0'B),
       LINE              CHAR (4096) VARYING,
       KEY               CHAR (12) VARYING,
       R                 POINTER,
       IDF_EOF           BIT (1) INIT ('0'B),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_RECORD_FROM_IDF';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   R      = NULL;

   CALL READ_IDF_RECORD (LINE,
                         IDF,
                         RECORD_ID,
                         IGNORE,
                         ERROR     );
   IF ERROR = '1'B
      THEN IDF_EOF = '1'B;
      ELSE DO;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('ABOUT TO ALLOCATE A RECORD NODE');
       %END;


       ALLOCATE RECORD_NODE SET (R);
       R-&gtRECORD_NODE.RECORD_ID         = RECORD_ID;
       R-&gtRECORD_NODE.IGNORE            = IGNORE;
       R-&gtRECORD_NODE.TABLE             = ' ';
       R-&gtRECORD_NODE.TABLE_OPEN        = '0'B;
       R-&gtRECORD_NODE.OPEN_OPTIONS      = ' ';
       R-&gtRECORD_NODE.TRANSACTION       = ' ';
       R-&gtRECORD_NODE.ABORT_ON_ERROR    = '0'B;
       R-&gtRECORD_NODE.VALID_RECORDS     = 0;
       R-&gtRECORD_NODE.INVALID_RECORDS   = 0;
       R-&gtRECORD_NODE.KEY_SIZE          = 0;
       R-&gtRECORD_NODE.LRECL             = 0;
       R-&gtRECORD_NODE.TOT_REC_SIZE      = 0;
       R-&gtRECORD_NODE.INIT_LIST_PTR     = NULL;
       R-&gtRECORD_NODE.FIELD_LIST_PTR    = NULL;
       R-&gtRECORD_NODE.NEXT_PTR          = NULL;
       R-&gtRECORD_NODE.KEY_FIELD_PTR     = NULL;
       R-&gtRECORD_NODE.BUFFER_PTR        = NULL;
       LAST_IDR_PTR = R;

       CALL READ_DEFINITION_FILE_LINE (LINE,IDF,KEY,ERROR);
       IF ERROR ^= '0'B
          THEN DO;
           STATUS = 12;
           IDF_EOF = '1'B;
           ERRMSG = 'UNEXPECTED END OF IMPORT DEFINITION FILE.';
           CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                            ERRMSG    );
           LAST_IDR_PTR = R;
          END;
      END; /* ELSE IF ERROR = '0'B */

   DO WHILE ((IDF_EOF    = '0'B)       &amp
             (TRIM(KEY) ^= 'END_RECORD') &amp
             (STATUS     = 0));
      KEY = TRIM(KEY);
      SELECT (KEY);
        WHEN ('TABLE')
         DO;
           CALL READ_IDF_TABLE
                            (LINE,
                             R-&gtRECORD_NODE.TABLE,
                             R-&gtRECORD_NODE.OPEN_OPTIONS,
                             ERROR                            );
           IF ERROR ^= '0'B
              THEN DO;
               STATUS = 12;
             ERRMSG = 'ERROR ENCOUNTERED IN IMPORT DEFINITION' ||
                      ' FILE, WHILE READING TABLE NAME FOR'  ||
                       ' RECORD DEFINITION.';
             CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                              ERRMSG    );

               LAST_IDR_PTR = R;
               IDF_EOF = '1'B;
              END;
              ELSE DO;
               CALL READ_DEFINITION_FILE_LINE (LINE,IDF,KEY,ERROR);
               IF ERROR = '1'B
                  THEN DO;
                   IDF_EOF = '1'B;
                   STATUS = 12;
                   ERRMSG = 'UNEXPECTED END OF IMPORT DEFINITION' ||
                            ' FILE, AFTER READING TABLE LINE.';
                   CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                    ERRMSG    );

                  END;
              END;
         END;

        WHEN ('TRANSACTION')
         DO;
           CALL READ_IDF_TRANSACTION
                             (LINE,
                              R-&gtRECORD_NODE.TRANSACTION,
                              R-&gtRECORD_NODE.ABORT_ON_ERROR,
                              ERROR                              );
           IF ERROR ^= '0'B
              THEN DO;
               STATUS = 12;
               ERRMSG = 'ERROR ENCOUNTERED IN IMPORT DEFINITION' ||
                        ' FILE, WHILE READING TRANSACTION FOR' ||
                        ' RECORD DEFINITION.';
               CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                ERRMSG    );

               LAST_IDR_PTR = R;
               IDF_EOF = '1'B;
              END;
              ELSE DO;
               CALL READ_DEFINITION_FILE_LINE (LINE,IDF,KEY,ERROR);
               IF ERROR = '1'B
                  THEN DO;
                   IDF_EOF = '1'B;
                   STATUS = 12;
                   ERRMSG = 'UNEXPECTED END OF IMPORT DEFINITION' ||
                            ' FILE, AFTER READING TRANSACTION LINE.';
                   CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                    ERRMSG    );
                  END;
              END;
         END;

        WHEN ('INITIALIZE')
         DO;
           R-&gtRECORD_NODE.INIT_LIST_PTR =
                              GET_INITIALIZE_LIST (IDF,
                                                   LINE,
                                                   KEY,
                                                   STATUS,
                                                   ERRLST_TOP);
         END;

        WHEN ('FIELD')
         DO;
           R-&gtRECORD_NODE.FIELD_LIST_PTR =
                              GET_FIELD_LIST (IDF,
                                              LINE,
                                              KEY,
                                              STATUS,
                                              ERRLST_TOP);
         END;

        WHEN ('END_RECORD')
         DO;
           ERROR = '0'B; /* END OF RECORD */
         END;

        OTHERWISE
         DO;
            STATUS = 12;
            ERRMSG = 'UNEXPECTED TOKEN ENCOUNTERED IN IMPORT' ||
                     ' DEFINITION FILE, TOKEN = ' || KEY;
            CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
            LAST_IDR_PTR = R;
            IDF_EOF = '1'B;
         END;

      END; /* OF SWITCH */

   END; /* OF WHILE NOT EOF OR KEY = END_RECORD*/

   /* LETS CHECK THE RECORD_ID */
   IF (STATUS = 0) &amp (^IDF_EOF)
      THEN DO;
       CALL  GET_DEFINITION_FILE_VALUE (LINE,
                                        RECORD_ID,
                                        1,
                                        ERROR);
       IF (ERROR) |
          (R-&gtRECORD_NODE.RECORD_ID ^= TRIM(RECORD_ID))
          THEN DO;
           STATUS = 12;
           ERRMSG = 'END_RECORD DID NOT MATCH RECORD. ' ||
                    'END_RECORD = ' || TRIM(RECORD_ID) ||
                    ' RECORD = '|| R-&gtRECORD_NODE.RECORD_ID;
           CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                            ERRMSG    );
        END;
      END;

   IF STATUS = 0 &amp
      IDF_EOF = '0'B
      THEN R-&gtRECORD_NODE.NEXT_PTR  =
                           GET_RECORD_FROM_IDF (IDF,
                                                LAST_IDR_PTR,
                                                STATUS,
                                                ERRLST_TOP);

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (R);

 /*------------------------------------------------------------------*/
 /*                        READ_IDF_RECORD                           */
 /*                                                                  */
 /* THIS PROCEDURE READS ONE OR MORE LINES FROM THE DEFINITION FILE  */
 /* WHICH IS PASSED IN AS A PARAMETER.  THIS PROCEDURE READS ALL     */
 /* COMMENT LINES UNTIL A LINE WITH THE ID OF 'RECORD' IS            */
 /* ENCOUNTERED.  THIS LINE SHOULD ALWAYS START AN INPUT DEFINITION  */
 /* DESCRIPTION.  THIS DEFINITION FOR THE RECORD IS LATER TERMINATED */
 /* BY AN END_RECORD LINE.                                           */
 /* IT THEN GETS THE FIRST DEFINITION RECORD NAME, WHICH IS          */
 /* IDENTIFIED BY THE FIRST TOKEN, AND THE OPTIONAL 'IGNORE' TOKEN,  */
 /* IF IT IS PRESENT.                                                */
 /*                                                                  */
 /* IMPUTS: LINE       - THE BUFFER WHERE THE LINE IS READ.          */
 /*         INPUT_FILE -  THE FILE TO BE READ.                       */
 /*                                                                  */
 /* OUTPUTS: LINE      - THE LAST LINE READ FROM THE INPUT_FILE.     */
 /*          RECORD_ID - THE RECORD_ID IDENTIFIED BY THE FIRST TOKEN.*/
 /*          IGNORE    - 0:  DO NOT IGNORE, 1: IGNORE RECORD IN THE  */
 /*                      INPUT FILE.                                 */
 /*          ERROR     - 0: PROCESSING WAS SUCCESSFULL, 1: ERROR.    */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/7/95                                                  */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_IDF_RECORD: PROC (LINE,INPUT_FILE,RECORD_ID,IGNORE,ERROR);

   DCL LINE              CHAR(*) VARYING,
       INPUT_FILE        FILE,
       RECORD_ID         CHAR (*) VARYING,
       IGNORE            BIT (1),
       ERROR             BIT (1),
       KEY               CHAR (80) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_IDF_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ERROR     = '0'B;
   RECORD_ID = ' ';
   IGNORE    = '0'B;

   CALL READ_DEFINITION_FILE_LINE (LINE,INPUT_FILE,KEY,ERROR);
   IF (ERROR = '0'B) &amp (TRIM(KEY) = 'RECORD')
      THEN CALL GET_DEFINITION_FILE_VALUE (LINE,RECORD_ID,1,ERROR);
      ELSE ERROR = '1'B;

   /* THIS IS OPTIONAL, SO IF NOT FOUND, RESET ERROR TO '0'B */

   IF ERROR = '0'B
      THEN DO;
       CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,2,ERROR);
       IF (ERROR = '0'B)
          THEN DO;
           IF (TRIM(KEY) = 'IGNORE')
               THEN IGNORE = '1'B;
               ELSE ERROR = '1'B;
         END;
         ELSE ERROR = '0'B;
     END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          IF ERROR = '0'B
             THEN PUT SKIP LIST ('RECORD ID = ',
                                  TRIM(RECORD_ID));
          PUT SKIP LIST ('IGNORE    = ',IGNORE);
          PUT SKIP LIST ('ERROR    = ',ERROR);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_IDF_RECORD;

 /*------------------------------------------------------------------*/
 /*                             READ_IDF_TABLE                       */
 /*                                                                  */
 /* THIS PROCEDURE PARSES THE IMPORT DEFINITION FILE LINE WHICH IS   */
 /* PASSED IN AS A PARAMETER.  IT SHOULD ONLY BE CALLED WITH A LINE  */
 /* THAT REPRESENTS A TABLE DEFINITION.  THIS PROCEDURE WILL RETURN  */
 /* THE TABLE, WHICH IS IDENTIFIED BY THE FIRST TOKEN, AND THE       */
 /* OPTIONAL VALUE FOR THE 'OPTIONS' TOKEN, IF IT IS PRESENT.        */
 /*                                                                  */
 /* IMPUTS: LINE - THE IMPORT DEFINITION FILE LINE.                  */
<A NAME="READ_IDF_TABLE"></A> /*                                                                  */
 /* OUTPUTS: TABLE_ID  - THE TABLE NAME IDENTIFIED BY THE FIRST      */
 /*                      TOKEN.                                      */
 /*          OPTIONS   - THE VALUE FOR THE OPTIONAL 'OPTIONS' TOKEN. */
 /*          ERROR     - 0: PROCESSING WAS SUCCESSFULL, 1: EOF.      */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/7/95                                                  */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_IDF_TABLE: PROC (LINE,TABLE_ID,OPTIONS,ERROR);

   DCL LINE              CHAR (*)  VARYING,
       TABLE_ID          CHAR (8),
       OPTIONS           CHAR (*) VARYING,
       ERROR             BIT (1),
       KEY               CHAR (80) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_IDF_TABLE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ERROR = '0'B;

   CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,1,ERROR);
   IF (ERROR = '0'B) &amp (KEY = 'TABLE')
       THEN DO;
         CALL GET_DEFINITION_FILE_VALUE (LINE,KEY,1,ERROR);
         TABLE_ID = TRIM (KEY);
       END;
       ELSE ERROR = '0'B;

   /* THIS IS OPTIONAL, SO IF NOT FOUND, RESET ERROR TO '0'B */

   IF ERROR = '0'B
      THEN DO;
       CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,2,ERROR);
       IF (ERROR = '0'B) &amp (KEY = 'OPTIONS')
           THEN CALL GET_DEFINITION_FILE_VALUE (LINE,OPTIONS,
                                                2,ERROR      );
       ERROR = '0'B;
     END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_IDF_TABLE;

 /*------------------------------------------------------------------*/
 /*                        READ_IDF_TRANSACTION                      */
 /*                                                                  */
 /* THIS PROCEDURE PARSES THE IMPORT DEFINITION FILE LINE WHICH IS   */
 /* PASSED IN AS A PARAMETER.  THIS PROCEDURE SHOULD ONLY BE CALLED  */
 /* WITH A LINE THAT CONTAINS THE DEFINITION FOR THE TRANSACTION.  IT*/
 /* WILL RETURN THE CHARACTER REPRESENTING THE TYPE OF TRANSACTION   */
 /* WHICH IS IDENTIFIED BY THE FIRST TOKEN, AND THE OPTIONAL VALUE   */
 /* FOR THE 'ERROR' TOKEN, IF IT IS PRESENT.                         */
 /*                                                                  */
 /* IMPUTS: LINE - THE IMPORT DEFINITION FILE LINE.                  */
 /*                                                                  */
 /* OUTPUTS: TRANSACTION  - THE TRANSACTION IDENTIFIED BY THE FIRST  */
 /*                         TOKEN.  'A': ADD, 'D': DELETE, 'F': FROM */
 /*                         DATA, 'U': UPDATE.                       */
 /*          ABORT        - THE VALUE FOR THE OPTIONAL 'ERROR' TOKEN,*/
 /*                         0: DONOT ABORT, 1: ABORT ON ERROR.       */
 /*          ERROR        - 0: PROCESSING WAS SUCCESSFULL, 1: ERROR. */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/8/95                                                  */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_IDF_TRANSACTION: PROC (LINE,TRANSACTION,ABORT,ERROR);

   DCL LINE              CHAR(*)  VARYING,
       TRANSACTION       CHAR (1),
       ABORT             BIT (1),
       ERROR            BIT (1),
       KEY               CHAR (80) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_IDF_TRANSACTION';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ERROR = '0'B;

   CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,1,ERROR);
   IF (ERROR = '0'B) &amp (KEY = 'TRANSACTION')
       THEN CALL GET_DEFINITION_FILE_VALUE (LINE,KEY,1,ERROR);
       ELSE ERROR = '0'B;

   IF ERROR = '0'B
      THEN DO;
       IF KEY = 'ADD'
          THEN TRANSACTION = 'A';
       ELSE IF KEY = 'DELETE'
          THEN TRANSACTION = 'D';
       ELSE IF KEY = 'FROM_DATA'
          THEN TRANSACTION = 'F';
       ELSE IF KEY = 'UPDATE'
          THEN TRANSACTION = 'U';
       ELSE ERROR = '1'B;
      END;

   /* THIS IS OPTIONAL, SO IF NOT FOUND, RESET ERROR TO '0'B */

   IF ERROR = '0'B
      THEN DO;
       CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,2,ERROR);
       IF (ERROR = '0'B) &amp (KEY = 'ERROR')
           THEN DO;
             CALL GET_DEFINITION_FILE_VALUE (LINE,KEY, 2,ERROR);
             IF KEY = 'ABORT'
                THEN ABORT = '1'B;
                ELSE ABORT = '0'B;
           END;
       ERROR = '0'B;
     END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_IDF_TRANSACTION;

 /*------------------------------------------------------------------*/
 /*                     GET_INITIALIZE_LIST                          */
 /*                                                                  */
 /* THIS FUNCTION READS THE INITIALIZE DEFINITIONS FROM THE IMPORT   */
 /* DEFINITION FILE.  THE FIRST INITIALIZE DEFINITION IS PASSED IN AS*/
 /* A PARAMETER.  THE FUNCTION INITIALIZES THE INIT NODE AND RETURNS */
 /* A POINTER TO THIS NODE.                                          */
 /* THIS PROCEDURE IS RECURSIVE AND TERMINATES WHEN EITHER THE END OF*/
 /* THE IMPORT DEFINITION FILE IS ENCOUNTERED, WHICH IS TREATED AS AN*/
 /* ERROR, OR UNTIL A LINE IS READ THAT IS NOT AN INITIALIZE         */
 /* DEFINITION LINE.                                                 */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   IDF          - THE IMPORT DEFINITION FILE HANDLE.              */
 /*                                                                  */
 /*   LINE         - THE LINE CONTAINING AN INITIALIZE DEFINITION.   */
 /*                  THIS PARAMETER IS ALSO RETURNED CONTAINING THE  */
 /*                  NEXT IMPORT DEFINITION LINE THAT IS NOT AN      */
 /*                  INITIALIZE DEFINITION.                          */
<A NAME="GET_INITIALIZE_LIST"></A> /*                                                                  */
 /*   KEY          - THE KEY OF THE LAST LINE READ.                  */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/12/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_INITIALIZE_LIST: PROC (IDF,LINE,KEY,STATUS,ERRLST_TOP )
                                                  RETURNS (POINTER);

   DCL IDF               FILE,
       LINE              CHAR (*) VARYING,
       KEY               CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       ERROR             BIT (1) INIT ('0'B),
       I                 POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_INITIALIZE_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ALLOCATE INIT_NODE SET (I);

   I-&gtINIT_NODE.NEXT_PTR   = NULL;
   I-&gtINIT_NODE.VAR_OFFSET = 0;
   I-&gtINIT_NODE.VAR_LENGTH = 0;

   CALL READ_IDF_INITIALIZE (LINE,
                             I-&gtINIT_NODE.VARIABLE,
                             I-&gtINIT_NODE.VALUE,
                             ERROR                 );
   IF ERROR = '0'B
      THEN DO;
        CALL READ_DEFINITION_FILE_LINE (LINE,IDF,KEY,ERROR);
        IF ERROR = '1'B
           THEN DO;
             STATUS = 12;
              ERRMSG = 'UNEXPECTED END OF IMPORT DEFINITION' ||
                       ' FILE, AFTER READING INITIALIZE LINE.';
              CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                               ERRMSG    );
            END;
           ELSE DO;

            IF TRIM(KEY) = 'INITIALIZE'
               THEN I-&gtINIT_NODE.NEXT_PTR =
                              GET_INITIALIZE_LIST (IDF,
                                                   LINE,
                                                   KEY,
                                                   STATUS,
                                                   ERRLST_TOP);

               ELSE I-&gtINIT_NODE.NEXT_PTR = NULL;

           END; /* ELSE */
      END;
      ELSE DO;
        STATUS = 12;
        ERRMSG = 'ERROR ENCOUNTERED IN IMPORT DEFINITION' ||
                 ' FILE, WHILE BUILDING INIT NODE.';
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                         ERRMSG    );
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (I);

 /*------------------------------------------------------------------*/
 /*                         READ_IDF_INITIALIZE                      */
 /*                                                                  */
 /* THIS PROCEDURE PARSES THE IMPORT DEFINITION FILE LINE WHICH IS   */
 /* PASSED IN AS A PARAMETER.  THIS PROCEDURE SHOULD ONLY BE CALLED  */
 /* WITH A LINE THAT CONTAINS THE DEFINITION FOR THE INITIALIZE.  IT */
<A NAME="READ_IDF_INITIALIZE"></A> /* WILL RETURN THE NAME OF THE FIELD, WHICH IS IDENTIFIED BY THE    */
 /* FIRST TOKEN, AND THE VALUE, WHICH IS IDENTIFIED BY THE SECOND    */
 /* TOKEN.  NOTE THAT BOTH TOKENS MUST BE PRESENT.                   */
 /*                                                                  */
 /* IMPUTS: LINE - THE IMPORT DEFINITION FILE LINE.                  */
 /*                                                                  */
 /* OUTPUTS: VARNAME  - THE NAME OF THE VARIABLE IDENTIFIED BY THE   */
 /*                     FIRST TOKEN                                  */
 /*          VARVALUE - THE VALUE FROM THE SECOND TOKEN.             */
 /*          ERROR        - 0: PROCESSING WAS SUCCESSFULL, 1: ERROR. */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/9/95                                                  */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_IDF_INITIALIZE: PROC (LINE,VARNAME,VARVALUE,ERROR);

   DCL LINE              CHAR (*)  VARYING,
       VARNAME           CHAR (8),
       VARVALUE          CHAR (*)  VARYING,
       ERROR            BIT (1),
       KEY               CHAR (80) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_IDF_INITIALIZE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ERROR = '0'B;

   CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,1,ERROR);
   IF (ERROR = '0'B) &amp (KEY = 'INITIALIZE')
       THEN CALL GET_DEFINITION_FILE_VALUE (LINE,VARVALUE,1,ERROR);
       ELSE ERROR = '0'B;

   IF ERROR = '0'B
      THEN DO;
       CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,2,ERROR);
       IF (ERROR = '0'B) &amp (KEY = 'VALUE')
           THEN CALL GET_DEFINITION_FILE_VALUE (LINE,
                                                VARVALUE,
                                                2,
                                                ERROR);
     END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_IDF_INITIALIZE;

 END GET_INITIALIZE_LIST;

 /*------------------------------------------------------------------*/
 /*                          GET_FIELD_LIST                          */
 /*                                                                  */
 /* THIS FUNCTION READS A FIELD DEFINITION LINE AND INITIALIZES THE  */
 /* STRUCTURES REQUIRED TO HOLD THE INFORMATION.  THE LINE CONTAINING*/
 /* THE FIELD DEFINITION IS PASSED IN AS A PARAMETER.   THIS         */
 /* PROCEDURE RETURNS A POINTER TO THE NEWLY CREATED FIELD NODE.     */
 /* THIS PROCEDURE IS RECURSIVE AND TERMINATES WHEN EITHER THE END OF*/
 /* THE IMPORT DEFINITION FILE IS ENCOUNTERED, WHICH IS TREATED AS AN*/
 /* ERROR, OR UNTIL A LINE IS READ THAT IS NOT A FIELD DEFINITION    */
 /* LINE.                                                            */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   IDF          - THE IMPORT DEFINITION FILE HANDLE.              */
<A NAME="GET_FIELD_LIST"></A> /*                                                                  */
 /*   LINE         - THE LINE CONTAINING A FIELD DEFINITION.         */
 /*                  THIS PARAMETER IS ALSO RETURNED CONTAINING THE  */
 /*                  NEXT IMPORT DEFINITION LINE.                    */
 /*                                                                  */
 /*   KEY          - THE KEY OF THE LAST LINE READ.                  */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/14/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_FIELD_LIST: PROC (IDF,LINE,KEY,STATUS,ERRLST_TOP)
                 RETURNS (POINTER);

   DCL IDF               FILE,
       LINE              CHAR (*) VARYING,
       KEY               CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       ERROR             BIT (1) INIT ('0'B),
       EDIT_STRING       CHAR (4096),
       F                 POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_FIELD_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   EDIT_STRING = ' ';
   ALLOCATE FIELD_NODE SET (F);

   F-&gtFIELD_NODE.EDIT_LIST_PTR   = NULL;
   F-&gtFIELD_NODE.NEXT_PTR        = NULL;
   F-&gtFIELD_NODE.VALUE           = ' ';
   F-&gtFIELD_NODE.VAR_OFFSET      = 0;
   F-&gtFIELD_NODE.VAR_LENGTH      = 0;

   CALL READ_IDF_FIELD (LINE,
                        F-&gtFIELD_NODE.VARIABLE,
                        F-&gtFIELD_NODE.IGNORE,
                        F-&gtFIELD_NODE.CONTAINS_ACTION,
                        F-&gtFIELD_NODE.CONTAINS_VALUE,
                        EDIT_STRING,
                        F-&gtFIELD_NODE.REQUIRED,
                        ERROR                        );
   IF ERROR = '0'B &amp
      EDIT_STRING ^= ' '
      THEN
       F-&gtFIELD_NODE.EDIT_LIST_PTR =
                      GET_EDIT_LIST (EDIT_STRING,
                                     STATUS,
                                     ERRLST_TOP  );

   IF ERROR = '0'B &amp
      STATUS = 0
      THEN DO;
        CALL READ_DEFINITION_FILE_LINE (LINE,IDF,KEY,ERROR);
        IF ERROR = '1'B
           THEN DO;
             STATUS = 12;
              ERRMSG = 'UNEXPECTED END OF IMPORT DEFINITION' ||
                       ' FILE, AFTER READING FIELD LINE.';
              CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                               ERRMSG    );
            END;
           ELSE DO;

            IF TRIM(KEY) = 'FIELD'
               THEN F-&gtFIELD_NODE.NEXT_PTR =
                                   GET_FIELD_LIST (IDF,
                                                   LINE,
                                                   KEY,
                                                   STATUS,
                                                   ERRLST_TOP);

               ELSE F-&gtFIELD_NODE.NEXT_PTR = NULL;

           END; /* ELSE */
      END;
      ELSE DO;
        STATUS = 12;
        ERRMSG = 'ERROR ENCOUNTERED IN IMPORT DEFINITION' ||
                 ' FILE, WHILE BUILDING FIELD NODE.';
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                         ERRMSG    );
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (F);

 /*------------------------------------------------------------------*/
 /*                           READ_IDF_FIELD                         */
 /*                                                                  */
 /* THIS PROCEDURE PARSES THE IMPORT DEFINITION FILE LINE WHICH IS   */
 /* PASSED IN AS A PARAMETER.  THIS PROCEDURE SHOULD ONLY BE CALLED  */
 /* WITH A LINE THAT CONTAINS THE DEFINITION FOR A FIELD.  IT RETURNS*/
 /* THE VALUE FOR THE FIELD AND THE OPTIONAL TOKENS AND VALUES.      */
 /* THE VALUE FOR THIS FIELD MAY CONTAIN THE '@', IN WHICH CASE IT   */
 /* WILL EITHER REPRESENT A TRANSACTION, OR THE CODE FOR IGNORE.     */
 /* IF IT CONTAINS A TRANSACTION, THE BIT, CONTAINS ACTION IS SET,   */
 /* OTHERWISE IF BIT, IGNORE, IS SET.                                */
 /* IF THE VALUE IS A VARIABLE, THEN THE BIT CONTAINS VALUE IS SET   */
 /* AND THE OPTIONAL EDIT TOKEN IS SEARCH FOR.  IF THE EDIT TOKEN IS */
 /* FOUND, THEN THE ENTIRE EDIT_STRING IS RETURNED.                  */
 /* THERE IS NOW AN OPTIONAL '/REQUIRED' WHICH WILL EITHER COME      */
 /* BEFORE THE '/EDIT' OR IN PLACE OF.                               */
 /*                                                                  */
 /* IMPUTS: LINE - THE IMPORT DEFINITION FILE LINE.                  */
 /*                                                                  */
 /* OUTPUTS:                                                         */
 /*      VARNAME          - EITHER THE VARIABLE NAME OR ONE OF THE   */
 /*                         FOLLOWING TRANSACTION CODES:             */
 /*                         'A': ADD, 'D': DELETE, 'U': UPDATE.      */
<A NAME="READ_IDF_FIELD"></A> /*      IGNORE           - IF THE VALUE CONTAINS '@IGNORE' THEN THIS*/
 /*                         IS SET TO 1, NO OTHER ACTION IS TAKEN.   */
 /*      CONTAINS_ACTION  - THIS BIT IS SET, IF THE VALUE CONTAINS   */
 /*                         A TRANSACTION, THE VARIABLE IS SET TO THE*/
 /*                         CORRECT TRANSACTION CODE.                */
 /*      CONTAINS_VALUE   - THIS BIT IS SET, IF THE VALUE IS NOT A   */
 /*                         TRANSACTION CODE, OR IT IS NOT '@IGNORE'.*/
 /*                         IF SET, THEN THE NEXT PARAMETER MAY BE   */
 /*                         RETURNED.                                */
 /*      EDIT_STRING      - THE EDIT STRING IF PRESENT.              */
 /*                                                                  */
 /*      REQUIRED         - IF '/REQUIRED' IS FOUND, THEN THIS IS    */
 /*                         SET TO '1'B, ELSE IT DEFAULTS TO '0'B.   */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/10/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_IDF_FIELD: PROC (LINE,VARNAME,IGNORE,CONTAINS_ACTION,
                        CONTAINS_VALUE,EDIT_STRING,REQUIRED,ERROR);

   DCL LINE              CHAR(*)  VARYING,
       VARNAME           CHAR (8),
       IGNORE            BIT (1),
       CONTAINS_ACTION   BIT (1),
       CONTAINS_VALUE    BIT (1),
       EDIT_STRING       CHAR (*),
       REQUIRED          BIT (1),
       ERROR            BIT (1),

       KEY               CHAR (4096) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_IDF_FIELD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   IGNORE          = '0'B;
   CONTAINS_ACTION = '0'B;
   CONTAINS_VALUE  = '0'B;
   ERROR           = '0'B;
   EDIT_STRING     = ' ';
   REQUIRED        = '0'B;
   VARNAME         = ' ';

   CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,1,ERROR);
   IF (ERROR = '0'B) &amp (KEY = 'FIELD')
       THEN CALL GET_DEFINITION_FILE_VALUE (LINE,KEY,1,ERROR);
       ELSE ERROR = '0'B;

   IF ERROR = '0'B
      THEN DO;
       IF SUBSTR(KEY,1,1) = '@'
          THEN DO;

            KEY = SUBSTR(KEY,2);
            KEY = TRIM (KEY);
            SELECT (KEY);
              WHEN ('IGNORE')
               DO;
                VARNAME = ' ';
                IGNORE = '1'B;
               END;
              WHEN ('ACTION')
               DO;
                VARNAME = '';
                CONTAINS_ACTION = '1'B;
               END;
              OTHERWISE
               DO;
                ERROR = '1'B;
                ERRMSG = 'INVALID ACTION AFTER &quot@&quot: ACTION ' ||
                         'ENCOUNTERED = ' || KEY;
                CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                 ERRMSG    );
               END;
            END;

           END;
           ELSE DO;
            CONTAINS_VALUE = '1'B;
            VARNAME = KEY;
           END;
         END;

   /* THIS IS OPTIONAL, SO IF NOT FOUND, RESET ERROR TO '0'B */

   IF CONTAINS_VALUE = '1'B
      THEN DO;
       KEY = ' ';
       CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,2,ERROR);

       IF (ERROR = '0'B)
           THEN DO;
             IF (TRIM(KEY) = 'REQUIRED')
                 THEN DO;
                  REQUIRED = '1'B;
                  KEY = ' ';
                  CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,
                                                  3,ERROR);
                 END;
           END;

        IF (ERROR = '0'B)
            THEN DO;
              IF (TRIM(KEY) = 'EDIT')
                 THEN DO;
                   KEY = ' ';
                   CALL GET_DEFINITION_FILE_VALUE (LINE,
                                                   KEY,
                                                   2,
                                                   ERROR);
                   EDIT_STRING = TRIM(KEY);
                 END;
                 ELSE DO;
                   ERROR = '1'B;
                   ERRMSG = 'INVALID TOKEN FOUND: '  ||
                             TRIM(KEY)               ||
                            ' EXPECTED TOKEN SHOULD' ||
                            ' BE &quotEDIT&quot.';
                     CALL ADD_MESSAGE_TO_MESSAGE_LIST
                                              (ERRLST_TOP,
                                               ERRMSG    );
                 END;
            END; /* OF ERROR = 0 */
            ELSE ERROR = '0'B;

      END; /* IF CONTAINS VALLUE */


  %IF DEBUGGER = 'ON'
       %THEN %DO;
         PUT SKIP LIST ('IGNORE          = ',IGNORE);
         PUT SKIP LIST ('CONTAINS ACTION = ',CONTAINS_ACTION);
         PUT SKIP LIST ('CONTAINS VALUE  = ',CONTAINS_VALUE);
         PUT SKIP LIST ('ERROR           = ',ERROR);
         PUT SKIP LIST ('VARIABLE NAME   = ',VARNAME);
         IF EDIT_STRING = ' '
            THEN PUT SKIP LIST ('EDIT STRING IS BLANK');
            ELSE PUT SKIP LIST ('EDIT STRING     = ',
                                 TRIM(EDIT_STRING));
         PUT SKIP LIST ('REQUIRED        = ',REQUIRED);
         IF ERROR
            THEN PUT SKIP LIST ('ERRMSG = ',TRIM(ERRMSG));
         PUT SKIP(2) LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_IDF_FIELD;
<A NAME="GET_EDIT_LIST"></A>
 /*------------------------------------------------------------------*/
 /*                            GET_EDIT_LIST                         */
 /*                                                                  */
 /* THIS PROCEDURE GETS THE EDITS ASSOCIATED WITH THE FIELD.  THERE  */
 /* IS ONLY ONE EDIT PER FIELD.                                      */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   EDIT_STRING  - CHAR (*) VARYING, THE STRING CONTAINING THE     */
 /*                  ENTIRE DATETIME EDIT.                           */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/14/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_EDIT_LIST: PROC (EDIT_STRING,STATUS,ERRLST_TOP) RETURNS (POINTER);

   DCL EDIT_STRING       CHAR(*),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       RECORD_ID         CHAR (80) VARYING,
       IGNORE            BIT (1) INIT ('0'B),
       ERROR             BIT (1) INIT ('0'B),
       LINE              CHAR (4096) VARYING,
       KEY               CHAR (12) VARYING,
       E                 POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_EDIT_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ALLOCATE EDIT_NODE SET (E);
   E-&gtEDIT_NODE.EDIT_TYPE = ' ';
   E-&gtEDIT_NODE.P1        = ' ';
   E-&gtEDIT_NODE.P2        = ' ';
   E-&gtEDIT_NODE.P3        = 0;
   E-&gtEDIT_NODE.P4        = 0;
   E-&gtEDIT_NODE.P5        = 0;
   E-&gtEDIT_NODE.P6        = '0'B;
   E-&gtEDIT_NODE.P7        = '0'B;
   E-&gtEDIT_NODE.P8        = NULL;
   E-&gtEDIT_NODE.P9        = NULL;

   IF INDEX(EDIT_STRING,':') &gt 0
      THEN KEY = WORD(EDIT_STRING,1,':');
      ELSE  KEY = WORD(EDIT_STRING,1,'=');


  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('KEY ',TRIM(KEY));
       %END;

   KEY = TRIM(KEY);
   SELECT (KEY);
    WHEN ('DATETIME')
     DO;
       E-&gtEDIT_NODE.EDIT_TYPE = 'D';
       CALL GET_DATETIME_FORMAT (EDIT_STRING,
                                 E-&gtEDIT_NODE.P3,
                                 E-&gtEDIT_NODE.P4,
                                 STATUS,
                                 ERRLST_TOP     );
    END;

    WHEN ('CODE')
     DO;
       E-&gtEDIT_NODE.EDIT_TYPE = 'C';
       E-&gtEDIT_NODE.P1 = WORD(EDIT_STRING,2,'=');
       IF E-&gtEDIT_NODE.P1  = ' '
          THEN DO;
            STATUS = 12;
            ERRMSG = 'ERROR IN EDIT FIELD FOR CODE, NO VALUE' ||
                     ' WAS FOUND.';
            CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
          END;
    END;

    WHEN ('INTEGER')
     DO;
         E-&gtEDIT_NODE.EDIT_TYPE = 'I';
         CALL GET_INTEGER_FORMAT (EDIT_STRING,
                                  E-&gtEDIT_NODE.P3,
                                  E-&gtEDIT_NODE.P6,
                                  E-&gtEDIT_NODE.P4,
                                  E-&gtEDIT_NODE.P1,
                                  STATUS,
                                  ERRLST_TOP     );
    END;

    WHEN ('REAL')
     DO;
         E-&gtEDIT_NODE.EDIT_TYPE = 'R';
         CALL GET_REAL_FORMAT (EDIT_STRING,
                               E-&gtEDIT_NODE.P3,
                               E-&gtEDIT_NODE.P4,
                               E-&gtEDIT_NODE.P6,
                               E-&gtEDIT_NODE.P7,
                               STATUS,
                               ERRLST_TOP       );
    END;

    WHEN ('VALUES')
     DO;
       E-&gtEDIT_NODE.EDIT_TYPE = 'V';
       LINE = SUBSTR (EDIT_STRING,8); /* SKIP THE 'VALUES=' */
       E-&gtEDIT_NODE.P8 = GET_VALUE_LIST (LINE,
                                         STATUS,
                                         ERRLST_TOP);
    END;

    OTHERWISE DO;
     STATUS = 12;
     ERRMSG = 'INVALID EDIT FOUND IN IMPORT DEFINITION FILE' ||
              ' EDIT = ' || KEY;
     CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                      ERRMSG    );
     END;

   END; /* OF SELECT */

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('STATUS = ',STATUS);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (E);
 /*------------------------------------------------------------------*/
 /*                       GET_DATETIME_FORMAT                        */
 /*                                                                  */
 /* THIS PROCEDURE RETURNS BOTH THE INPUT AND OUTPUT FORMATS FOR THE */
<A NAME="GET_DATETIME_FORMAT"></A> /* DATE TIME EDIT.                                                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   EDIT_STRING  - CHAR (*) VARYING, THE STRING CONTAINING THE     */
 /*                  ENTIRE DATETIME EDIT.                           */
 /*                                                                  */
 /*   INPUT_FORMAT - FIX BIN(15), THE INPUT FORMAT.  ONLY VALUE IS 1.*/
 /*                  MM/DD/YYYY/ HH:MM:SS.                           */
 /*                                                                  */
 /*   OUTPUT_FORMAT - FIX BIN(15), THE OUTPUT FORMAT.  POSSIBLE      */
 /*                  VALUES: 1 - YYMMDD; 2 - YYMMDDHHMMSS,           */
 /*                          3 - YYMMDDHHMM                          */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/13/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_DATETIME_FORMAT: PROC (EDIT_STRING,INPUT_FORMAT,OUTPUT_FORMAT,
                            STATUS,ERRLST_TOP                 );

   DCL EDIT_STRING       CHAR (*),
       INPUT_FORMAT      FIXED BIN (15),
       OUTPUT_FORMAT     FIXED BIN (15),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       STRING            CHAR (80) VARYING,
       FORMAT            CHAR (40) VARYING,
       I                 FIXED BIN (15),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_DATETIME_FORMAT';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   /* SKIP THE 'DATETIME:INPUT=&quot' IN THE EDIT_STRING */
   I = INDEX(EDIT_STRING,'&quot');
   STRING = SUBSTR(EDIT_STRING,I+1);

   /* NOW FIND THE ENDING '&quot' */
   I = INDEX (STRING,'&quot');

   /* GET THE INPUT FORMAT */
   FORMAT = SUBSTR (STRING,1,I-1);

   IF (TRIM(FORMAT) = 'MM/DD/YYYY HH:MM:SS') |
      (TRIM(FORMAT) = 'MM/DD/YY HH:MM:SS')
      THEN INPUT_FORMAT = 1;
      ELSE DO;
       STATUS = 12;
       ERRMSG = 'INVALID INPUT FORMAT ENCOUNTERED,' ||
                ' FORMAT = ' || FORMAT;
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;

    /* NOW SUBSTRING THE STRING PAST '&quot:OUTPUT =&quot' */
    STRING = SUBSTR (STRING,I+10);

    /* NOW FIND THE ENDING '&quot' */
    I = INDEX (STRING,'&quot');

    /* GET THE OUTPUT FORMAT */

    FORMAT = SUBSTR(STRING,1,I-1);

    SELECT;
      WHEN (TRIM(FORMAT) = 'YYMMDD')
        OUTPUT_FORMAT = 1;
      WHEN (TRIM (FORMAT) = 'YYMMDDHHMMSS')
        OUTPUT_FORMAT = 2;
      WHEN (TRIM (FORMAT) = 'YYMMDDHHMM')
        OUTPUT_FORMAT = 3;
      OTHERWISE
       DO;
         STATUS = 12;
         ERRMSG = 'INVALID OUTPUT FORMAT ENCOUNTERED,' ||
                  ' FORMAT = ' || FORMAT;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                          ERRMSG    );
       END;
    END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('STATUS = ',STATUS);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;
<A NAME="GET_INTEGER_FORMAT"></A>
   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_DATETIME_FORMAT;

 /*------------------------------------------------------------------*/
 /*                         GET_INTEGER_FORMAT                       */
 /*                                                                  */
 /* THIS PROCEDURE READS THE EDIT STRING TO GET THE EDITS REQUIRED   */
 /* TO FORMAT AN INTEGER VALUE.                                      */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   EDIT_STRING  - CHAR (*) VARYING, THE STRING CONTAINING THE     */
 /*                  INTEGER VALUE.                                  */
 /*                                                                  */
 /*   LEN          - FIX BIN(15), THE LENGTH FOR THE BINARY NUMBER   */
 /*                                                                  */
 /*   SIGNED       - BIT (1), WHETHER OR NOT AN SIGNED INTEGER IS    */
 /*                  ALLOWED. 0 - NO; 1 - YES                        */
 /*                                                                  */
 /*   JUSTIFY      - FIX BIN(15), WHAT TYPE OF JUSTIFICATION.        */
 /*                  0 - NONE; 1 - LEFT; 2 - RIGHT.                  */
 /*                                                                  */
 /*   FILL         - FILL CHARACTER - DEFAULT IS BLANKS.             */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/13/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_INTEGER_FORMAT: PROC (EDIT_STRING,LEN,SIGNED,JUSTIFY,FILL,
                           STATUS,ERRLST_TOP                  );

   DCL EDIT_STRING       CHAR (*),
       LEN               FIXED BIN (15),
       SIGNED            BIT (1),
       JUSTIFY           FIXED BIN (15),
       FILL              CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       STRING            CHAR (80),
       VALUE             CHAR (2),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_INTEGER_FORMAT';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   STRING = WORD (EDIT_STRING,2,':');
   VALUE  = WORD (STRING,2,'=');

   LEN = BINARY(VALUE,15);

   STRING = WORD (EDIT_STRING,3,':');
   IF STRING = 'SIGNED'
      THEN DO;
       SIGNED = '1'B;
       STRING = WORD (EDIT_STRING,4,':');
      END;

   IF STRING = 'LEFT'
      THEN DO;
       JUSTIFY = 1;
       STRING = WORD (EDIT_STRING,5,':');
      END;
      ELSE
        IF STRING = 'RIGHT'
           THEN DO;
             JUSTIFY = 2;
             STRING = WORD (EDIT_STRING,5,':');
           END;
<A NAME="GET_REAL_FORMAT"></A>
   IF STRING ^= ' '
      THEN FILL = WORD (STRING,2,'+');

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_INTEGER_FORMAT;


 /*------------------------------------------------------------------*/
 /*                           GET_REAL_FORMAT                        */
 /*                                                                  */
 /* THIS PROCEDURE READS THE EDIT STRING TO GET THE EDITS REQUIRED   */
 /* TO FORMAT A REAL VALUE.                                          */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   EDIT_STRING  - CHAR (*) VARYING, THE STRING CONTAINING THE     */
 /*                  REAL VALUE.                                     */
 /*                                                                  */
 /*   PRECISION    - FIX BIN(15), THE TOTAL NUMBER OF DIGITS         */
 /*                                                                  */
 /*   SCALE        - FIXED BIN(15), NUMBER OF DECIMAL DIGITS.        */
 /*                                                                  */
 /*   SIGNED       - BIT (1), WHETHER OR NOT AN SIGNED INTEGER IS    */
 /*                  ALLOWED. 0 - NO; 1 - YES                        */
 /*                                                                  */
 /*   FORMAT       - BIT(1), FORMATTING REQUIRED.                    */
 /*                  0 - NONE; 1 - YES.                              */
 /*                                                                  */
 /*   FILL         - FILL CHARACTER - DEFAULT IS BLANKS.             */
 /*                                                                  */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/15/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_REAL_FORMAT: PROC (EDIT_STRING,PRECISION,SCALE,SIGNED,FORMAT,
                        STATUS,ERRLST_TOP                        );


   DCL EDIT_STRING       CHAR (*),
       PRECISION         FIXED BIN (15),
       SCALE             FIXED BIN (15),
       SIGNED            BIT (1),
       FORMAT            BIT (1),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       STRING            CHAR (80),
       KEY               CHAR (40),
       VALUE             CHAR (2),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_REAL_FORMAT';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('EDIT STRING ',TRIM(EDIT_STRING));
       %END;

   PRECISION = 0;
   SCALE     = 0;
   SIGNED    = '0'B;
   FORMAT    = '0'B;


   /* GET THE PRECISION */
   STRING = WORD (EDIT_STRING,2,':');

    KEY = WORD(STRING,1,'=');

    IF TRIM(KEY) = 'PRECISION'
       THEN DO;
        VALUE  = WORD (STRING,2,'=');
        PRECISION = BINARY(VALUE,15);
       END;
       ELSE DO;
        STATUS = 12;
        ERRMSG = 'THE TOKEN &quotPRECISION&quot WAS EXPECTED AS ' ||
                 'PART OF EDIT=REAL.  TOKEN IN FILE '     ||
                 TRIM(KEY);
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                         ERRMSG    );
       END;

   /* GET THE SCALE */

   IF STATUS = 0
      THEN DO;
       STRING = WORD (EDIT_STRING,3,':');

       KEY = WORD(STRING,1,'=');
       IF TRIM(KEY) = 'SCALE'
          THEN DO;
           VALUE  = WORD (STRING,2,'=');
           SCALE = BINARY(VALUE,15);
          END;
          ELSE DO;
           STATUS = 12;
            ERRMSG = 'THE TOKEN &quotSCALE&quot WAS EXPECTED AS ' ||
                     'PART OF EDIT=REAL.  TOKEN IN FILE ' ||
                      TRIM(KEY);
            CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
          END;

      END;
<A NAME="GET_VALUE_LIST"></A>
   IF STATUS = 0  /* OPTIONAL */
      THEN DO;
       STRING = WORD (EDIT_STRING,4,':');
       IF TRIM(STRING) = 'SIGNED'
          THEN DO;
            SIGNED = '1'B;
            STRING = WORD (EDIT_STRING,5,':');
          END;

       IF TRIM(STRING) = 'FORMAT'
           THEN FORMAT = '1'B;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_REAL_FORMAT;


 /*------------------------------------------------------------------*/
 /*                           GET_VALUE_LIST                         */
 /*                                                                  */
 /* THIS PROCEDURE READS A VALUE FROM THE LIST OF VALUES PASSED AS   */
 /* PARAMETERS.  IT ALLOCATES AND SETS ONE VALUE_LIST_NODE.          */
 /* THIS PROCEDURE IS RECURSIVE, AND TERMINATES WHEN THERE ARE NO    */
 /* MORE VALUES WITHIN THE LIST.                                     */
 /*                                                                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   VALUE_STRING - CHAR (*) VARYING, THE STRING CONTAINING THE     */
 /*                  LIST OF VALUES.                                 */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/15/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_VALUE_LIST: PROC (VALUE_STRING,STATUS,ERRLST_TOP)
                       RETURNS (POINTER);

   DCL VALUE_STRING      CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       VALUE             CHAR (80) VARYING,
       I                 FIXED BIN (15),
       L                 FIXED BIN (15),
       VAL_PTR           POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_VALUE_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('VALUE STRING = ',TRIM(VALUE_STRING));
          PUT SKIP LIST ('LENGTH OF TRIMED VALUE STRING = ',
                          LENGTH(TRIM(VALUE_STRING)));
       %END;

   I  = INDEX (VALUE_STRING,',');
   L  = LENGTH(TRIM(VALUE_STRING));
<A NAME="READ_DEFINITION_FILE_LINE"></A>   IF I = 0
      THEN I = L + 1;

   VALUE        = SUBSTR (VALUE_STRING,1,I-1);

   IF I &gt= L
      THEN VALUE_STRING = ' ';
      ELSE VALUE_STRING = SUBSTR (VALUE_STRING,I+1);

   ALLOCATE VALUE_LIST_NODE SET (VAL_PTR);
   VAL_PTR-&gtVALUE_LIST_NODE.VALUE = VALUE;
   IF VALUE_STRING ^= ' '
      THEN
        VAL_PTR-&gtVALUE_LIST_NODE.NEXT_PTR =
                                  GET_VALUE_LIST (VALUE_STRING,
                                                  STATUS,
                                                  ERRLST_TOP);
        ELSE
         VAL_PTR-&gtVALUE_LIST_NODE.NEXT_PTR = NULL;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (VAL_PTR);

 END GET_VALUE_LIST;

 END GET_EDIT_LIST;

 END GET_FIELD_LIST;

 END GET_RECORD_FROM_IDF;

 /*------------------------------------------------------------------*/
 /*                    READ_DEFINITION_FILE_LINE                     */
 /*                                                                  */
 /* THIS PROCEDURE READS ONE OR MORE LINES FROM THE DEFINITION FILE  */
 /* WHICH IS PASSED IN AS A PARAMETER.  THIS PROCEDURE READS ALL     */
 /* COMMENT LINES UTIL THE FIRST NON COMMENT LINE IS ENCOUNTERED.    */
 /* IT THEN GETS THE FIRST DEFINITION FILE TOKEN FOR THIS LINE AND   */
 /* RETURNS IT AS THE KEY FOR THIS LINE.                             */
 /*                                                                  */
 /* IMPUTS: LINE - THE BUFFER WHERE THE LINE IS READ.                */
 /*         INPUT_FILE -  THE FILE TO BE READ.                       */
 /*                                                                  */
 /* OUTPUTS: LINE - THE LAST LINE READ FROM THE INPUT_FILE.          */
 /*          KEY - THE FIRST DEFINITION FILE TOKEN IN THE LINE.      */
 /*          ERROR:  0 - PROCESSING WAS SUCCESSFULL, 1 - END OF FILE.*/
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/06/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 READ_DEFINITION_FILE_LINE: PROC (LINE,INPUT_FILE,KEY,ERROR);

   DCL LINE              CHAR(*) VARYING,
       INPUT_FILE        FILE,
       KEY               CHAR (*) VARYING,
       ERROR             BIT (1),
       EOF_INPUT_FILE    BIT (1) INIT('0'B),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'READ_DEFINITION_FILE_LINE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ERROR = '0'B;
   KEY    = ' ';

   ON ENDFILE (INPUT_FILE) EOF_INPUT_FILE = '1'B;

   READ FILE (INPUT_FILE)
        INTO (LINE);

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('FIRST READ');
          PUT SKIP LIST ('LINE = ',LINE);
          PUT SKIP LIST ('EOF INPUT FILE = ',EOF_INPUT_FILE);
       %END;

   DO WHILE (((SUBSTR(LINE,1,1) = '!') |
             (SUBSTR(LINE,1,1) = ';')) &amp
             (^EOF_INPUT_FILE));

      READ FILE (INPUT_FILE)
           INTO (LINE);

  %IF DEBUGGER = 'ON'
<A NAME="GET_DEFINITION_FILE_TOKEN"></A>       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF WHILE A COMMENT LINE ');
          IF EOF_INPUT_FILE
             THEN PUT SKIP LIST ('END OF IDF FILE.');
             ELSE PUT SKIP LIST ('LINE = ',LINE);
          PUT SKIP LIST ('EOF INPUT FILE = ',EOF_INPUT_FILE);
       %END;

   END;

   IF ^EOF_INPUT_FILE
       THEN CALL GET_DEFINITION_FILE_TOKEN (LINE,KEY,1,ERROR);
       ELSE DO;
         ERROR = '1'B;
         LINE = ' ';
       END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          IF ^EOF_INPUT_FILE
              THEN DO;
               PUT SKIP LIST ('LINE           = ',LINE);
               PUT SKIP LIST ('KEY            = ',KEY);
              END;
          PUT SKIP LIST ('ERROR         = ',ERROR);
          PUT SKIP LIST ('EOF INPUT FILE = ',EOF_INPUT_FILE);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END READ_DEFINITION_FILE_LINE;

 /*------------------------------------------------------------------*/
 /*                    GET_DEFINITION_FILE_TOKEN                     */
 /*                                                                  */
 /* THIS PROCEDURE RETURNS A DEFINITION FILE TOKEN FROM THE LINE     */
 /* PASSED IN AS A PARAMETER.  DEFINITION FILE TOKENS EITHER BEGIN   */
 /* AT THE BEGINNING OF THE LINE OR AFTER A '/'. THEY ARE TERMINATED */
 /* BY AN EQUAL SIGN.  THE NUMBER PASSED IN IS USED TO DETERMINE     */
 /* WHICH TOKEN SHOULD BE RETURNED.                                  */
 /* IT IS ALSO POSSIBLE FOR A TOKEN TO END WITH A '/' AS WELL AS A   */
 /* '='.                                                             */
 /*                                                                  */
 /* INPUTS: LINE: THE LINE TO BE PARSED FOR THE DEFINITION FILE      */
 /*               TOKEN.                                             */
 /*         TOKEN_NUMBER: THE NUMBER OF THE TOKEN TO BE RETURNED.    */
 /*                                                                  */
 /* OUTPUTS: TOKEN: THE TOKEN COORESPONDING TO THE TOKEN_NUMBER FOUND*/
 /*                 IN THE LINE.                                     */
 /*          ERROR:   0 - PROCESSING WAS SUCCESSFULL,                */
 /*                   1 - END OF LINE ENCOUNTERED.                   */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/06/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_DEFINITION_FILE_TOKEN: PROC (LINE,TOKEN,TOKEN_NUMBER,ERROR);

   DCL LINE              CHAR(*) VARYING,
       TOKEN             CHAR (*) VARYING,
       TOKEN_NUMBER      FIXED BIN (15),
       ERROR             BIT (1),
       TMP_STRING        CHAR (4096) VARYING,
       FRST_POS          FIXED BIN (15),     /* POSITIONAL       */
       SCND_POS          FIXED BIN (15),     /* POSITIONAL       */
       I                 FIXED BIN (15),     /* POSITIONAL       */
       L                 FIXED BIN (15),     /* LENGTH OF STRING */
       CNT               FIXED BIN (15),     /* COUNT            */
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_DEFINITION_FILE_TOKEN';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('LINE = ',LINE);
          PUT SKIP LIST ('TOKEN NUMBER = ',TOKEN_NUMBER);
       %END;

    ERROR = '0'B;

   /* CHECK TO INSURE THAT THE STRING IS NOT BLANK */
   /* AND NOT  NULL, BEFORE CONTINUEING            */

    IF LINE = ' '
       THEN ERROR = '1'B;   /* BLANK STRING */

    IF LENGTH(LINE) = 0
       THEN ERROR = '1'B;   /* NULL STRING */

    /* GET THE START OF THE TOKEN, THIS CORRESPONDS TO*/
    /* EITHER THE START OF THE LINE, OR FINDING '/'   */
    /* TOKEN_NUMBER - 1 NUMBER OF TIMES.              */

    IF TOKEN_NUMBER = 1
       THEN DO;
         FRST_POS = 0;
         TMP_STRING = LINE;
       END;

       ELSE DO;
        CNT = 2; /* GETTING THE SECOND TOKEN */
        FRST_POS = INDEX (LINE,'/');
        IF FRST_POS = 0
           THEN ERROR =  '1'B;  /* NO MORE TOKENS */

        DO WHILE (ERROR = '0'B &amp
                  CNT &lt TOKEN_NUMBER);
           TMP_STRING = SUBSTR(LINE,FRST_POS+1);
           CNT = CNT + 1;
           I = INDEX (TMP_STRING,'/');
           IF I = 0
              THEN ERROR = '1'B;  /* TOKEN NOT FOUND */
              ELSE FRST_POS = FRST_POS + I;
        END; /* WHILE */
       END; /* ELSE */

   IF ERROR = '0'B
      THEN DO;

<A NAME="GET_DEFINITION_FILE_VALUE"></A>      /* SUBSTRING LINE, SO THE '/' IS SKIPPED, THIS WILL */
      /* PUT THE TOKEN AT THE START OF THE SUBSTRING.     */
      /* IF THE TOKEN IS ALREADY AT THE START, THEN       */
      /* THIS WILL RETURN THE ENTIRE LINE.                */

        TMP_STRING = SUBSTR(LINE,FRST_POS+1);
        SCND_POS = INDEX (TMP_STRING,'=');
        IF SCND_POS = 0
           THEN SCND_POS = LENGTH(TRIM(TMP_STRING)) + 1;
      END;

   /* NOW RETREIVE THE TOKEN */

   IF ERROR = '0'B
      THEN DO;
        TOKEN = SUBSTR (TMP_STRING,1,SCND_POS-1);

        /* CHECK FOR ANOTHER '/' IN THE TOKEN, IF FOUND */
        /* THEN SUBSTRING AGAIN.                        */

        SCND_POS = INDEX (TOKEN,'/');
        IF SCND_POS &gt 0
           THEN TOKEN  = SUBSTR (TOKEN,1,SCND_POS - 1);
      END;
      ELSE TOKEN = ' ';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('TOKEN = ',TOKEN);
          PUT SKIP (2) LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_DEFINITION_FILE_TOKEN;

 /*------------------------------------------------------------------*/
 /*                    GET_DEFINITION_FILE_VALUE                     */
 /*                                                                  */
 /* THIS PROCEDURE RETURNS A DEFINITION FILE VALUE FROM THE LINE     */
 /* PASSED IN AS A PARAMETER.  DEFINITION FILE VALUES BEGIN WITH AN  */
 /* EQUAL SIGN AND ARE TERMINATED WITH EITHER THE END OF LINE OR A   */
 /* '/'.  THE VALUES MAY OPTIONALLY BE ENCLOSED IN DOUBLE QUOTES.    */
 /*                                                                  */
 /* INPUTS: LINE: THE LINE TO BE PARSED FRO THE DEFINITION FILE      */
 /*               VALUE.                                             */
 /*         VALUE_NUMBER: THE NUMBER OF THE VALUE TO BE RETURNED.    */
 /*                                                                  */
 /* OUTPUTS: VALUE: THE VALUE COORESPONDING TO THE VALUE_NUMBER FOUND*/
 /*                 IN THE LINE.                                     */
 /*          ERROR:   0 - PROCESSING WAS SUCCESSFULL,                */
 /*                   1 - END OF LINE ENCOUNTERED.                   */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/06/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_DEFINITION_FILE_VALUE: PROC (LINE,VALUE,VALUE_NUMBER,ERROR);

   DCL LINE              CHAR(*) VARYING,
       VALUE             CHAR (*) VARYING,
       VALUE_NUMBER      FIXED BIN (15),
       ERROR             BIT (1),
       TMP_STRING        CHAR (4096) VARYING,
       FRST_POS          FIXED BIN (15),     /* POSITIONAL       */
       SCND_POS          FIXED BIN (15),     /* POSITIONAL       */
       I                 FIXED BIN (15),     /* POSITIONAL       */
       L                 FIXED BIN (15),     /* LENGTH OF STRING */
       CNT               FIXED BIN (15),     /* COUNT            */
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_DEFINITION_FILE_VALUE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('LINE = ',LINE);
          PUT SKIP LIST ('VALUE NUMBER = ',VALUE_NUMBER);
        %END;

    ERROR     = '0'B;
    TMP_STRING = ' ';
    VALUE      = ' ';

   /* CHECK TO ENSURE THAT THE STRING IS NOT BLANK */
   /* AND NOT  NULL, BEFORE CONTINUING             */

    IF LINE = ' '
       THEN ERROR = '1'B;   /* BLANK STRING */

    IF LENGTH(TRIM(LINE)) = 0
       THEN ERROR = '1'B;   /* NULL STRING */
       ELSE DO;

        /* GET THE START OF THE VALUE, THIS CORRESPONDS TO*/
        /* FINDING '=' VALUE_NUMBER OF TIMES.             */

        CNT = 1; /* GETTING THE SECOND VALUE */
        FRST_POS = INDEX (LINE,'=');
        IF FRST_POS = 0
           THEN ERROR =  '1'B;  /* NO MORE VALUES */

        DO WHILE (ERROR = '0'B &amp
                  CNT &lt VALUE_NUMBER);
           TMP_STRING = SUBSTR(LINE,FRST_POS+1);
           CNT = CNT + 1;
           I = INDEX (TMP_STRING,'=');
           IF I = 0
              THEN ERROR = '1'B;  /* VALUE NOT FOUND */
              ELSE FRST_POS = FRST_POS + I;
        END; /* WHILE */
       END; /* ELSE */

   IF ERROR = '0'B
      THEN DO;

      /* SUBSTRING LINE, SO THE '=' IS SKIPPED, THIS WILL */
      /* PUT THE VALUE AT THE START OF THE SUBSTRING.     */

        TMP_STRING = SUBSTR(LINE,FRST_POS+1);
<A NAME="OPEN_IMPORT_FILES"></A>
        SCND_POS = INDEX (TMP_STRING,'/');
        IF (SCND_POS = 0) |
           ((SCND_POS &gtINDEX(TMP_STRING,'&quot')) &amp
             (INDEX(TMP_STRING,'&quot') &gt0))
           THEN SCND_POS = LENGTH (TRIM(TMP_STRING)) + 1;
      END;

   /* NOW GET THE VALUE. */

   IF ERROR = '0'B
      THEN DO;
 /*        IF SCND_POS = LENGTH(TMP_STRING)
           THEN VALUE = SUBSTR (TMP_STRING,1);
           ELSE
 */
       VALUE = SUBSTR (TMP_STRING,1,SCND_POS-1);
      END;
      ELSE VALUE = ' ';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          IF VALUE = ' '
             THEN PUT SKIP LIST ('VALUE WAS BLANK');
             ELSE PUT SKIP LIST ('VALUE = ',TRIM(VALUE));
          PUT SKIP LIST ('ERROR = ',ERROR);
          PUT SKIP(2) LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_DEFINITION_FILE_VALUE;

 /*------------------------------------------------------------------*/
 /*                            OPEN_IMPORT_FILES                     */
 /*                                                                  */
 /* THIS PROCEDURE TRAVERSES THE IMPORT DEFINITION FIELD LIST AND    */
 /* OPENS ALL TABLES SPECIFIED IN THE NODE, USING THE OPTIONS FOUND  */
 /* IN THE NODE.                                                     */
 /* THIS PROCEDURE FINISHES THE INITIALIZATION OF THE CSV DATA       */
 /* STRUCTURES: THE KEY_FIELD_LIST, ALL VARIABLE'S LENGTH AND        */
 /* OFFSET.   IN THE PROCESS IT SETS THE TABLE SIZE AND THE TOTAL    */
 /* SIZE OF ALL FIELDS IN BOTH THE INIT LIST AND FIELD LIST.         */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   IDRPTR       - POINTER TO THE LIST OF RECORD NODES.            */
 /*                                                                  */
 /*   RECORD_PTR   - POINTER TO STRUCTURE TO BE USED WHEN OPENING    */
 /*                 THE DATABASE FILES.                              */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/15/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 OPEN_IMPORT_FILES: PROC (IDRPTR,STATUS,ERRLST_TOP);
   DCL IDRPTR            POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       R                 POINTER,
       BUF_PTR           POINTER,
       FIXED_OPTIONS     CHAR (80),
       CODETBLS_OPEN     BIT (1) INIT ('0'B),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'OPEN_IMPORT_FILES';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   R = IDRPTR;
   IF R = NULL
      THEN DO;
        STATUS = 12;
        ERRMSG = 'FAILED TO LOAD IMPORT DEFINITION, NO RECORD' ||
                 ' DEFINITIONS FOUND';
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                         ERRMSG    );
      END;

   ALLOCATE BUFFER SET (BUF_PTR);

   DO WHILE (R ^= NULL);

     %IF DEBUGGER = 'ON'
         %THEN %DO;
            PUT SKIP LIST ('INSIDE OF WHILE, RECORD_ID = ',
                            R-&gtRECORD_NODE.RECORD_ID);
         %END;

      IF R-&gtRECORD_NODE.OPEN_OPTIONS = ' '
         THEN FIXED_OPTIONS = ' ';
         ELSE
          FIXED_OPTIONS = TRIM(R-&gtRECORD_NODE.OPEN_OPTIONS);

      IF ^(R-&gtRECORD_NODE.IGNORE) &amp
          (R-&gtRECORD_NODE.TABLE ^= ' ')
          THEN DO;

           IF TRIM(R-&gtRECORD_NODE.TABLE) = 'CODETBLS'
              THEN CODETBLS_OPEN = '1'B;

           ITRC = ITOPEN (TRIM(R-&gtRECORD_NODE.TABLE),
                          BUF_PTR,'WRITE',' ',' ',
                          FIXED_OPTIONS);

           IF ITRC = 0
              THEN DO;
               R-&gtRECORD_NODE.TABLE_OPEN = '1'B;
               R-&gtRECORD_NODE.BUFFER_PTR = BUF_PTR;
               CALL GET_KEY_FIELDS (R-&gtRECORD_NODE.TABLE,
                                  R-&gtRECORD_NODE.KEY_FIELD_PTR,
                                  R-&gtRECORD_NODE.KEY_SIZE,
                                  STATUS,
                                  ERRLST_TOP               );

               CALL GET_FIELD_INFO (R-&gtRECORD_NODE.TABLE,
                                    R,
                                    STATUS,
                                    ERRLST_TOP           );

              END;
              ELSE DO;
                STATUS = 12;
<A NAME="GET_KEY_FIELDS"></A>                ERRMSG = 'TABLE ' ||
                         TRIM (R-&gtRECORD_NODE.TABLE) ||
                         'NOT OPENED';
                CALL ADD_MESSAGE_TO_MESSAGE_LIST
                                       (ERRLST_TOP,
                                        ERRMSG    );
              END;

          END; /* IF NOT IGNORE */

      R = R-&gtRECORD_NODE.NEXT_PTR;

   END;

   /* OPEN THE CODE TABLES FILE */

   IF (STATUS = 0) &amp (^CODETBLS_OPEN)
      THEN DO;
       ALLOCATE BUFFER SET (BUF_PTR);
       ITRC = ITOPEN ('CODETBLS',BUF_PTR,'READ',' ',' ',' ');
       IF ITRC ^= 0
          THEN DO;
            STATUS = 12;
            ERRMSG = 'CODE TABLES NOT OPENED ';
            CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
          END;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          CALL DUMP_RECORDS (IDRPTR);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*------------------------------------------------------------------*/
 /*                           GET_KEY_FIELDS                         */
 /*                                                                  */
 /* THIS PROCEDURE CONSTRUCTS THE LINKED LIST OF PRIMARY KEYS FOR    */
 /* TABLE.  THIS IS DONE THROUGH THREE SETS OF ITQUERY CALLS.  THE   */
 /* FIRST WIL GET THE LIST OF KEY NAMES, THE OTHER TWO WILL GET THE  */
 /* OFFSET AND LENGTH OF EACH KEY.                                   */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   TABLE        - DATABASE TABLE.                                 */
 /*                                                                  */
 /*   KEYS_PTR     - POINTER TO THE LIST OF KEYS FOR THIS TABLE.     */
 /*                                                                  */
 /*   RECORD_PTR   - POINTER TO STRUCTURE TO BE USED WHEN OPENING    */
 /*                 THE DATABASE FILES.                              */
 /*                                                                  */
 /*   KEY_SIZE     - THE TOTAL SOZE OF THE KEY FOR THIS TABLE.       */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/21/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_KEY_FIELDS: PROC (TABLE,KEYS_PTR,KEY_SIZE,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       KEYS_PTR          POINTER,
       KEY_SIZE          FIXED BIN(15),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       PTR               POINTER,
       IT1_BUFFER        CHAR (150),
       IT2_BUFFER        CHAR (154) VARYING,
       VARIABLE          CHAR (12) VARYING,
       ITRC              FIXED BIN (15) INIT (0),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_KEY_FIELDS';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('TABLE = ',TABLE);
       %END;

  IT2_BUFFER = ' ';
  ITRC = ITQUERY ('KEYFIELDS ' || TRIM(TABLE),
                  IT1_BUFFER                 );

  IF ITRC ^= 0
     THEN DO;
      STATUS = 12;
      ERRMSG = 'ITQUERY FAILED, WHILE GETTING KEYFIELDS '   ||
               'FOR THE TABLE ' || TRIM(TABLE)            ||
               '.  ITRC = ' || TRIM(CHAR(ITRC));
      CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                       ERRMSG    );
    END;

    KEY_SIZE = 0;

    IF STATUS = 0
       THEN DO;
        IT2_BUFFER = TRIM(IT1_BUFFER);

        ALLOCATE KEY_FIELD_NODE SET (KEYS_PTR);
        CALL NEXT_TOKEN (IT2_BUFFER,
                         ' ',
                         VARIABLE);
        KEYS_PTR-&gtKEY_FIELD_NODE.VARIABLE = VARIABLE;
        KEYS_PTR-&gtKEY_FIELD_NODE.VALUE    = ' ';
        CALL GET_VAR_INFO (TABLE,
                           KEYS_PTR-&gtKEY_FIELD_NODE.VARIABLE,
                           KEYS_PTR-&gtKEY_FIELD_NODE.VAR_OFFSET,
                           KEYS_PTR-&gtKEY_FIELD_NODE.VAR_LENGTH,
                           KEY_SIZE,
                           STATUS,
                           ERRLST_TOP                    );

        KEYS_PTR-&gtKEY_FIELD_NODE.NEXT_PTR  = NULL;
        PTR = KEYS_PTR;
       END;

  IF STATUS = 0  /* SET UP THE NEXT KEY */
     THEN DO;
       IT2_BUFFER = TRIM(IT2_BUFFER);
       CALL NEXT_TOKEN (IT2_BUFFER,
                        ' ',
                        VARIABLE);
      END;
<A NAME="GET_FIELD_INFO"></A>

  DO WHILE ((VARIABLE ^= ' ') &amp
            (STATUS = 0));

        ALLOCATE KEY_FIELD_NODE SET
                               (PTR-&gtKEY_FIELD_NODE.NEXT_PTR);
        PTR = PTR-&gtKEY_FIELD_NODE.NEXT_PTR;

        PTR-&gtKEY_FIELD_NODE.VARIABLE = VARIABLE;

        CALL GET_VAR_INFO (TABLE,
                           PTR-&gtKEY_FIELD_NODE.VARIABLE,
                           PTR-&gtKEY_FIELD_NODE.VAR_OFFSET,
                           PTR-&gtKEY_FIELD_NODE.VAR_LENGTH,
                           KEY_SIZE,
                           STATUS,
                           ERRLST_TOP                  );


        PTR-&gtKEY_FIELD_NODE.NEXT_PTR  = NULL;

        IT2_BUFFER = TRIM(IT2_BUFFER);
        CALL NEXT_TOKEN (IT2_BUFFER,
                         ' ',
                         VARIABLE);
        IF LENGTH(TRIM(VARIABLE)) &lt= 1
           THEN VARIABLE = ' ';


  END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LENGTH OF KEYS = ',KEY_SIZE);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_KEY_FIELDS;


 /*------------------------------------------------------------------*/
 /*                           GET_FIELD_INFO                         */
 /*                                                                  */
 /* THIS PROCEDURE TRAVERSES THE LIST OF FIELD NODES AND GETS THE    */
 /* LENGTH AND OFFSET FOR THE VARIABLE.  IT THEN TRAVERSES THE LIST  */
 /* OF INIT NODES TO GET THE LENGTH AND OFFSET FOR EACH NODE IN THE  */
 /* INIT LIST.                                                       */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   TABLE        - DATABASE TABLE.                                 */
 /*                                                                  */
 /*   R            - POINTER TO THE RECORD NODE.                     */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/21/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_FIELD_INFO: PROC (TABLE,R,STATUS,ERRLST_TOP);


   DCL TABLE             CHAR (8),
       R                 POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ERRMSG            CHAR (512) VARYING,
       PTR               POINTER,
       IT_BUFFER         CHAR (150),
       ITRC              FIXED BIN (15) INIT (0),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_FIELD_INFO';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('TABLE = ',TABLE);
       %END;

  R-&gtRECORD_NODE.TOT_REC_SIZE = 0;

  IF R ^= NULL
      THEN DO;

      /* GET THE LOGICAL RECORD LENGTH */
      ITRC = ITQUERY ('LRECL ' || TRIM(TABLE), IT_BUFFER);
      IF ITRC ^= 0
         THEN DO;
          STATUS = 12;
          ERRMSG = 'ITQUERY FAILED, WHILE GETTING LRECL ' ||
                   'FOR THE TABLE: ' || TRIM(TABLE)     ||
                   '.  ITRC = ' || TRIM(CHAR(ITRC));
          CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                           ERRMSG    );
         END;
         ELSE R-&gtRECORD_NODE.LRECL =
                            BINARY (TRIM(IT_BUFFER),15);

        PTR = R-&gtRECORD_NODE.FIELD_LIST_PTR;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('WORKING THE FIELD LIST');
       %END;

        DO WHILE ((PTR ^= NULL) &amp (STATUS = 0));
           IF (PTR-&gtFIELD_NODE.CONTAINS_VALUE) &amp
               (^(PTR-&gtFIELD_NODE.IGNORE))
              THEN
                CALL GET_VAR_INFO (TABLE,
                                   PTR-&gtFIELD_NODE.VARIABLE,
                                   PTR-&gtFIELD_NODE.VAR_OFFSET,
                                   PTR-&gtFIELD_NODE.VAR_LENGTH,
                                   R-&gtRECORD_NODE.TOT_REC_SIZE,
<A NAME="GET_VAR_INFO"></A>                                   STATUS,
                                   ERRLST_TOP              );
           PTR = PTR-&gtFIELD_NODE.NEXT_PTR;

        END;

      END;
      ELSE PTR = NULL;

  IF R ^= NULL
      THEN DO;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('WORKING THE INIT LIST');
       %END;
        PTR = R-&gtRECORD_NODE.INIT_LIST_PTR;
        DO WHILE ((PTR ^= NULL) &amp (STATUS = 0));
           CALL GET_VAR_INFO (TABLE,
                              PTR-&gtINIT_NODE.VARIABLE,
                              PTR-&gtINIT_NODE.VAR_OFFSET,
                              PTR-&gtINIT_NODE.VAR_LENGTH,
                              R-&gtRECORD_NODE.TOT_REC_SIZE,
                              STATUS,
                              ERRLST_TOP                );
           PTR = PTR-&gtINIT_NODE.NEXT_PTR;
        END;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_FIELD_INFO;

 /*------------------------------------------------------------------*/
 /*                           GET_VAR_INFO                           */
 /*                                                                  */
 /* THIS PROCEDURE GETS BOTH THE OFFSET AND LENGTH FOR THE DATABASE  */
 /* FIELD PASSED IN.  THIS IS DONE THROUGH TWO SETS OF ITQUERY       */
 /* CALLS.                                                           */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   TABLE        - DATABASE TABLE.                                 */
 /*                                                                  */
 /*   VARAIBLE     - THE VARAIBLE WITHIN THE TABLE BEING QUERIED     */
 /*                                                                  */
 /*   OFFSET       - THE OFFSET INTO THE BUFFER WHERE THIS VARIABLE  */
 /*                  STARTS.                                         */
 /*                                                                  */
 /*   LENGTH       - THE LENGTH OF THE VARIABLE.                     */
 /*                                                                  */
 /*   TOT_LEN      - THE TOTAL LENGTH OF ALL VARIABLES.              */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/21/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_VAR_INFO: PROC (TABLE,VARIABLE,OFFSET,LENGTH,TOT_LEN,
                     STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       VARIABLE          CHAR (8),
       OFFSET            FIXED BIN (15),
       LENGTH            FIXED BIN (15),
       TOT_LEN           FIXED BIN (15),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

<A NAME="NEXT_TOKEN"></A>       ERRMSG            CHAR (512) VARYING,
       TBL_VAR           CHAR (17),
       IT_BUFFER         CHAR (150),
       ITRC              FIXED BIN (15) INIT (0),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_VAR_INFO';

  %IF DEBUGGER = 'ON'
       %THEN %DO;

          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('TABLE    = ',TABLE);
          PUT SKIP LIST ('VARIABLE = ',VARIABLE);
          PUT SKIP LIST ('TOTAL LENGTH SO FAR = ',TOT_LEN);
       %END;

  TBL_VAR = TRIM(TABLE) || '.' || TRIM(VARIABLE);
  ITRC = ITQUERY ('OFFSET ' || TBL_VAR, IT_BUFFER);
  IF ITRC ^= 0
      THEN DO;
       STATUS = 12;
       ERRMSG = 'ITQUERY FAILED, WHILE GETTING VARIABLE INFO ' ||
                'FOR THE TABLE: ' || TRIM(TABLE)             ||
                ' AND VARIABLE: ' || VARIABLE                ||
                '.  ITRC = ' || TRIM(CHAR(ITRC));
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;
      ELSE OFFSET = BINARY (TRIM(IT_BUFFER),15);

  ITRC = ITQUERY ('LENGTH ' || TBL_VAR, IT_BUFFER);
  IF ITRC ^= 0
      THEN DO;
       STATUS = 12;
       ERRMSG = 'ITQUERY FAILED, WHILE GETTING VARIABLE INFO ' ||
                'FOR THE TABLE: ' || TRIM(TABLE)             ||
                ' AND VARIABLE: ' || VARIABLE                ||
                '.  ITRC = ' || TRIM(CHAR(ITRC));
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;
      ELSE DO;
       LENGTH = BINARY (TRIM(IT_BUFFER),15);
       TOT_LEN = TOT_LEN + LENGTH;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;

          PUT SKIP LIST ('OFFSET = ',OFFSET);
          PUT SKIP LIST ('LENGTH = ',LENGTH);
          PUT SKIP LIST ('TOTAL LENGTH NOW = ',TOT_LEN);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_VAR_INFO;

 END OPEN_IMPORT_FILES;

 /*-----------------------------------------------------------------*/
 /*                             NEXT_TOKEN                          */
 /*                                                                 */
 /*  GIVEN A SEPARATOR CHARACTER, EXTRACT THE NEXT TOKEN FROM THE   */
 /*  SUPPLIED BUFFER.  THE TOKEN AND THE SEPARATOR WILL BE REMOVED  */
 /*  FROM THE BUFFER.                                               */
 /*                                                                 */
 /*  WRITTEN BY : RTD  11/18/88                                     */
 /*                                                                 */
 /*-----------------------------------------------------------------*/

 NEXT_TOKEN: PROC (BUFFER,SEPARATOR,TOKEN);

  DCL BUFFER                 CHAR(*) VARYING,
      SEPARATOR              CHAR(*),
      TOKEN                  CHAR(*) VARYING,
      I                      FIXED BIN (15),
      LENGTH                 BUILTIN,
      SHELL$MODULE_SEGMENT   CHAR(31) EXTERNAL,
      SAVE_SEGMENT           CHAR(31);

  SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
  SHELL$MODULE_SEGMENT = 'NEXT_TOKEN';

  IF BUFFER = ''
     THEN DO;
       TOKEN = '';
       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
       RETURN;
     END;

  I = INDEX(BUFFER,SEPARATOR);

  SELECT;
     WHEN (I = 0)
       DO;
         TOKEN  = BUFFER;
         BUFFER = '';
       END;

     WHEN (I = 1)
       DO;
         TOKEN = '';
         IF LENGTH(BUFFER) = 1
            THEN BUFFER = '';
<A NAME="IMPORT_NEXT_CSV_RECORD"></A>            ELSE BUFFER = SUBSTR(BUFFER,I+1);
       END;

    OTHERWISE
      DO;
       TOKEN  = SUBSTR(BUFFER,1,I-1);
       BUFFER = SUBSTR(BUFFER,I+1);
      END;
   END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END NEXT_TOKEN;

 END INITIALIZE_CSV_IMPORT;

 /*------------------------------------------------------------------*/
 /*                      IMPORT_NEXT_CSV_RECORD                      */
 /*                                                                  */
 /* THIS PROCEDURE READS THE NEXT RECORD FROM THE IMPORT FILE.  IF   */
 /* THE RECORD BEGINS WITH A ';', THE RECORD IS IGNORED AND THE      */
 /* PROCEDURE RETURNS.  OTHERWISE, IT GETS THE RECORD_ID FROM THE    */
 /* RECORD JUST READ AND USES THIS RECORD ID TO SEARCH THE IMPORT    */
 /* DEFINITION LIST FOR A MATCHING MATCH.  IF A MATCH IS NOT FOUND,  */
 /* AN ERROR IS GENERATED AND THE PROCEDURE TERMINATES.  IF A MATCH  */
 /* IS MADE, THEN THE RECORD IS PROCESSED ACCORDING TO THE           */
 /* SPECIFICATIONS IDENTIFIED BY THE RECORD NODE.                    */
 /* PARAMETERS:                                                      */
 /*     IMPORT    - FILE ID FOR THE OPENED IMPORT FILE.              */
 /*                 NOTE THAT THE FILE MUST BE OPENED BEFORE CALLING */
 /*                 THIS FUNCTION.                                   */
 /*                                                                  */
 /*     IDSPTR    - POINTER TO THE IMPORT DEFINITION DATA STRUCTURE. */
 /*                                                                  */
 /*     RECORD_ID - RECORD ID OF IMPORT RECORD PROCESSED.            */
 /*                                                                  */
 /*     TABLE     - NAMED OF TABLE ASSOCIATED WITH THE IMPORT RECORD */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 2  - RECORD IS A COMMENT RECORD.                 */
 /*                 4  - END OF IMPORT FILE ENCOUNTERED.             */
 /*                 6  - RECORD WAS IGNORED.                         */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 10 - TRANSACTION ERROR ENCOUNTERED.              */
 /*                 12 - INVALID RECORD ENCOUNTERED IN IMPORT FILE.  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /* INCLUDES NEEDED BY THIS PROCEDURE                                */
 /* IDFSTRUCT.PLI  - THE IMPORT DEFINITION FILE DATA STRUCTURES      */
 /* PARSE_CSV_RECORD.PLI                                             */
 /* MESSAGE.PLI                                                      */
 /* VERIFY_REAL_VALUE.PLI                                            */
 /* VERIFY_DATETIME_VALUE.PLI                                        */
 /* VERIFY_INTEGER_VALUE.PLI                                         */
 /* VERIFY_VALUE_IS_IN_LIST.PLI                                      */
 /* VERIFY_CODE_VALUE.PLI                                            */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/17/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  THIS IS A   */
 /*               GLOBAL CHANGE TO EVERY ERROR MESSAGE.              */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 IMPORT_NEXT_CSV_RECORD: PROC (IMPORT,IDSPTR,RECORD_ID,TABLE,
                               KEY_VALUE,STATUS,ERRLST_TOP);

   DCL IMPORT            FILE,
       IDSPTR            POINTER,
       RECORD_ID         CHAR (*) VARYING,
       TABLE             CHAR (8),
       KEY_VALUE         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       IMPORT_EOF        BIT (1) INIT ('0'B),
       IMP_RECORD        CHAR (4096) VARYING,

       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'IMPORT_NEXT_CSV_RECORD';

   %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT FILE (SYSPRINT) PAGE;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   ON ENDFILE (IMPORT) IMPORT_EOF = '1'B;
   ON UNDEFINEDFILE (IMPORT) IMPORT_EOF = '1'B;

   RECORD_ID   = ' ';
<A NAME="PROCESS_IMPORT_RECORD"></A>   TABLE       = ' ';
   KEY_VALUE   = ' ';
   STATUS      = 0;

   READ FILE (IMPORT) INTO (IMP_RECORD);

   IF IMPORT_EOF
      THEN STATUS = 4;
      ELSE DO;
        IF SUBSTR(IMP_RECORD,1,1) = ';'
           THEN STATUS = 2;
           ELSE CALL PROCESS_IMPORT_RECORD
                     (IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR,
                      IMP_RECORD,
                      RECORD_ID,
                      TABLE,
                      KEY_VALUE,
                      STATUS,
                      ERRLST_TOP                                 );
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;


 /*------------------------------------------------------------------*/
 /*                     PROCESS_INPUT_RECORD                         */
 /*                                                                  */
 /* THIS PROCEDURE STARTS THE PROCESSING FOR THE IMPORT RECORD.  IT  */
 /* SEARCHES THE DEFINITION LIST IN MEMORY FOR A MATCHING RECORD ID. */
 /* IF ONE IS FOUND, IT CHECKS TO SEE IF THE RECORD NEEDS TO BE      */
 /* IGNORED, IF SO IT SETS THE RECORD_ID AND THE STATUS.  OTHERWISE, */
 /* IT CALLS THE PROCEDURE PROCESS_FIELDS TO CONTINUE PROCESSING.    */
 /* IF A MATCH WAS NOT FOUND, AN ERROR IS GENERATED AND THE STATUS IS*/
 /* SET 12 - INVALID RECORD.                                         */
 /*                                                                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     IDRPTR    - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*     IMP_RECORD - INPUT RECORD.                                   */
 /*                                                                  */
 /*     RECORD_ID - RECORD ID OF IMPORT RECORD PROCESSED.            */
 /*                                                                  */
 /*     TABLE     - NAMED OF TABLE ASSOCIATED WITH THE IMPORT RECORD.*/
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 6  - RECORD WAS IGNORED.                         */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 10 - TRANSACTION ERROR ENCOUNTERED.              */
 /*                 12 - INVALID RECORD ENCOUNTERED IN IMPORT FILE.  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/17/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.              */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_IMPORT_RECORD: PROC (IDRPTR,IMP_RECORD,RECORD_ID,TABLE,
                              KEY_VALUE,STATUS,ERRLST_TOP);

   DCL IDRPTR            POINTER,
       IMP_RECORD        CHAR (*) VARYING,
       RECORD_ID         CHAR (*) VARYING,
       TABLE             CHAR (8),
       KEY_VALUE         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       R                 POINTER,
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_IMPORT_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   CALL PARSE_CSV_RECORD(IMP_RECORD,1,RECORD_ID,STATUS);
   IF STATUS ^= 0
      THEN DO;
        STATUS = 16;
        ERRMSG = 'RECORD ID WAS NOT RETURNED FROM PARSE_CSV_RECORD' ||
                 ' STATUS RETURNED: ' || CHAR(STATUS);
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;

      ELSE DO;
         R  = GET_RECORD_PTR (IDRPTR,
                              RECORD_ID);
         IF R = NULL
            THEN DO;
             STATUS = 12;
             ERRMSG = 'RECORD ID: '               ||
                      TRIM(RECORD_ID)             ||
                      '  WAS NOT FOUND IN IMPORT' ||
                      ' DEFINITION RECORD LIST.';
             CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
            END;
      END;

   IF STATUS = 0
      THEN DO;

       IF R-&gtRECORD_NODE.IGNORE
          THEN STATUS = 6;
          ELSE DO;
           IF R-&gtRECORD_NODE.FIELD_LIST_PTR ^= NULL
              THEN DO;
                TABLE = R-&gtRECORD_NODE.TABLE;
                CALL PROCESS_IMPORT_FIELDS (IMP_RECORD,
                                            R,
                                            KEY_VALUE,
                                            STATUS,
                                            ERRLST_TOP);
              END;
              ELSE DO;
                STATUS = 16;
                ERRMSG = 'RECORD ID: ' || TRIM(RECORD_ID) ||
                         ' WAS NOT IGNORED, BUT THERE WERE ' ||
                         'NO FIELDS DEFINED FOR THE RECORD.';
                CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                  ERRMSG    );
             END;
          END;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*------------------------------------------------------------------*/
 /*                        GET_RECORD_PTR                            */
 /*                                                                  */
 /* THIS PROCEDURE SEARCHES THE LIST OF RECORD NODES FOR A MATCH ON  */
 /* RECORD ID.  IT WILL RETURN EITHER A NULL POINTER IF A MATCH WAS  */
 /* NOT FOUND, OR THE POINTER TO THE MATCHING NODE.                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     IDRPTR    - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*     RECORD_ID - RECORD ID OF IMPORT RECORD PROCESSED.            */
 /*                                                                  */
 /* RETURNS POINTER;                                                 */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/17/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
<A NAME="PROCESS_IMPORT_FIELDS"></A> /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_RECORD_PTR: PROC (IDRPTR,RECORD_ID) RETURNS (POINTER);

   DCL IDRPTR            POINTER,
       RECORD_ID         CHAR (*) VARYING,

       R                 POINTER INIT (NULL),
       FOUND             BIT (1) INIT ('0'B),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_RECORD_PTR';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   R = IDRPTR;

   DO WHILE ((R ^= NULL) &amp
             (^FOUND));

      IF RECORD_ID = R-&gtRECORD_NODE.RECORD_ID
         THEN FOUND = '1'B;
         ELSE R = R-&gtRECORD_NODE.NEXT_PTR;

   END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (R);

   END GET_RECORD_PTR;

 /*------------------------------------------------------------------*/
 /*                       PROCESS_IMPORT_FIELDS                      */
 /*                                                                  */
 /* THIS PROCEDURE PROCESSES THE IMPORT RECORD.  IT FIRST DETERMINES */
 /* THE TRANSACTION TO BE DONE, EITHER BY OBTAINING THE CODE FROM    */
 /* RECORD NODE OR SEARCHING THE FIELD LIST AND IMPORT RECORD FOR THE*/
 /* FIELD THAT CONTAINS THE TRANSACTION.  NEXT IT INITIALIZES THE    */
 /* THAT WILL RECEIVE THE NEW RECORD.  THEN IT FINISHES PROCESSING   */
 /* THE IMPORT RECORD.  FINALLY IT PERFORMS THE TRANSACTION.         */
 /*                                                                  */
 /* PARAMETERS                                                       */
 /*                                                                  */
 /*     IMP_RECORD - INPUT RECORD.                                   */
 /*                                                                  */
 /*     R         - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 10 - TRANSACTION ERROR ENCOUNTERED.              */
 /*                 12 - INVALID RECORD ENCOUNTERED IN IMPORT FILE.  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/17/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PROCEDURES THAT DO NOT HAVE ACCESS    */
 /*               TO IT.                                             */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_IMPORT_FIELDS: PROC (IMP_RECORD,R,KEY_VALUE,
                              STATUS,ERRLST_TOP           );

   DCL IMP_RECORD        CHAR(*) VARYING,
       R                 POINTER,
       KEY_VALUE         CHAR (*) VARYING,
       IGNORE            BIT (1),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       TRANSACTION       CHAR (1),
       TABLE             CHAR (8),
       ERRMSG            CHAR (32) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_IMPORT_FIELDS';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

    TRANSACTION = R-&gtRECORD_NODE.TRANSACTION;
    IF (TRANSACTION = 'F')
       THEN
        CALL GET_TRANSACTION_CODE
                            (R-&gtRECORD_NODE.FIELD_LIST_PTR,
                             IMP_RECORD,TRANSACTION       );

    /* INITIALIZE THE BUFFER USED TO HOLD THE  */
    /* FIELDS PROCESSED FROM THE IMPORT RECORD */

    TABLE = R-&gtRECORD_NODE.TABLE;
    R-&gtBUFFER_PTR-&gtBUFFER = ' ';
    IF R-&gtRECORD_NODE.INIT_LIST_PTR ^= NULL
       THEN
         CALL PROCESS_INIT_LIST (TABLE,
                                 R-&gtRECORD_NODE.BUFFER_PTR,
                                 R-&gtRECORD_NODE.INIT_LIST_PTR,
                                 R-&gtRECORD_NODE.RECORD_ID,
                                 STATUS,
                                 ERRLST_TOP                  );

   /* COMPLETE THE PROCESSING OF THE FIELDS WITHIN THE */
   /* IMPORT RECORD                                    */

    CALL PROCESS_FIELD_LIST (TABLE,
                             R-&gtRECORD_NODE.BUFFER_PTR,
                             R-&gtRECORD_NODE.FIELD_LIST_PTR,
                             IMP_RECORD,
                             R-&gtRECORD_NODE.RECORD_ID,
                             STATUS,
                             ERRLST_TOP                   );

    CALL DETERMINE_KEY_VALUE (TABLE,
                              R-&gtRECORD_NODE.BUFFER_PTR,
<A NAME="GET_TRANSACTION_CODE"></A>                              KEY_VALUE,
                              R-&gtRECORD_NODE.KEY_SIZE,
                              R-&gtRECORD_NODE.KEY_FIELD_PTR,
                              R-&gtRECORD_NODE.RECORD_ID,
                              STATUS,
                              ERRLST_TOP);

    /* NOW DO THE TRANSACTION IF THERE WERE NO ERRORS */

    IF STATUS = 0
        THEN DO;

           SELECT (TRANSACTION);
             WHEN ('A')
               CALL ADD_RECORD (TABLE,
                                R,
                                KEY_VALUE,
                                STATUS,
                                ERRLST_TOP);
             WHEN ('U')
               CALL UPDATE_RECORD (TABLE,
                                   R,
                                   KEY_VALUE,
                                   STATUS,
                                   ERRLST_TOP);
             WHEN ('D')
               CALL DELETE_RECORD (TABLE,
                                   KEY_VALUE,
                                   R-&gtRECORD_NODE.KEY_SIZE,
                                   R-&gtRECORD_NODE.RECORD_ID,
                                   STATUS,
                                   ERRLST_TOP);
             OTHERWISE DO;
               STATUS = 12;
               ERRMSG = 'RECORD ID: '                         ||
                         TRIM(R-&gtRECORD_NODE.RECORD_ID)       ||
                         '  TRANSACTION CODE WAS INVALID.  '  ||
                         ' TRANSACTION CODE = '  ||
                        TRANSACTION;
               CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                               ERRMSG    );
             END;
           END;

         END;

    /* INCREMENT THE COUNT OF RECORDS PROCESSED */

    IF STATUS = 0
       THEN R-&gtRECORD_NODE.VALID_RECORDS  = 1 +
              R-&gtRECORD_NODE.VALID_RECORDS;
       ELSE R-&gtRECORD_NODE.INVALID_RECORDS = 1 +
              R-&gtRECORD_NODE.INVALID_RECORDS;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*------------------------------------------------------------------*/
 /*                          GET_TRANSACTION_CODE                    */
 /*                                                                  */
 /* THIS PROCEDURE IS ONLY CALLED IF THE TRANSACTION CODE AT THE     */
 /* RECORD NODE IS SET TO 'F'ROM DATA.  THIS PROCEDURE COMPUTES THE  */
 /* POSITION OF THE TRANSACTION CODE WITHIN THE IMPORT RECORD, BY    */
 /* TRAVERSING THE FIELD LIST UNTIL THE CONTAINS_TRANSACTION BIT IS  */
 /* SET.  IT THEN READS THE IMPORT RECORD WITH THIS COUNT TO RETURN  */
 /* THE TRANSACTION CODE.                                            */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     IDFPTR    - POINTER TO LIST OF FIELD NODES.                  */
 /*                                                                  */
 /*     RECORD_ID - RECORD ID OF IMPORT RECORD PROCESSED.            */
 /*                                                                  */
 /*     TRANSACTION - THE TRANSACTION CODE.                          */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 GET_TRANSACTION_CODE: PROC (IDFPTR, IMP_RECORD,TRANSACTION);


   DCL IDFPTR            POINTER,
       IMP_RECORD        CHAR (*) VARYING,
       TRANSACTION       CHAR (1),

       F                 POINTER,
       CSV_VALUE         CHAR (80) VARYING,
       COUNT             FIXED BIN (15) INIT (1),
       FOUND             BIT (1) INIT ('0'B),
       STATUS            FIXED BIN (15),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_TRANSACTION_CODE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   TRANSACTION = ' ';
   F = IDFPTR;
   DO WHILE ((F ^= NULL) &amp
             (^FOUND));

      COUNT = COUNT + 1;
      IF F-&gtFIELD_NODE.CONTAINS_ACTION
         THEN FOUND = '1'B;
         ELSE F = F-&gtFIELD_NODE.NEXT_PTR;

   END;

   CALL PARSE_CSV_RECORD(IMP_RECORD,COUNT,CSV_VALUE,STATUS);
   IF STATUS = 0
      THEN TRANSACTION = SUBSTR(CSV_VALUE,1,1);

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST  ('TRANSACTION CODE = ',TRANSACTION);
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END GET_TRANSACTION_CODE;

 /*------------------------------------------------------------------*/
 /*                          PROCESS_FIELD_LIST                      */
 /*                                                                  */
 /* THIS PROCEDURE TRAVERSES THE FIELD NODE LIST, AND FOR EACH NODE  */
 /* THAT DOES NOT HAVE THE IGNORE BIT SET, IT PROCESSES THE          */
 /* COORESPONDING FIELD WITHIN THE IMPORT RECORD.                    */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     IDRPTR    - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*     IMP_RECORD - THE IMPORT RECORD.                              */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 12 - INVALID RECORD ENCOUNTERED IN IMPORT FILE.  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /* RETURNS POINTER;                                                 */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST.                       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_FIELD_LIST: PROC  (TABLE,BUF_PTR,IDFPTR,IMP_RECORD,RECORD_ID,
                            STATUS,ERRLST_TOP      );

   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       IDFPTR            POINTER,
       IMP_RECORD        CHAR (*) VARYING,
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       COUNT             FIXED BIN (15) INIT (1),
       F                 POINTER,
<A NAME="PROCESS_FIELD"></A>       TMP_STATUS        FIXED BIN (15),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_FIELD_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   TMP_STATUS = STATUS;
   F = IDFPTR;
   DO WHILE (F ^= NULL);

      COUNT = COUNT + 1;
      IF ^F-&gtFIELD_NODE.IGNORE &amp
         ^F-&gtFIELD_NODE.CONTAINS_ACTION
         THEN DO;
           CALL PROCESS_FIELD (TABLE,
                               BUF_PTR,
                               IMP_RECORD,
                               COUNT,
                               F,
                               RECORD_ID,
                               STATUS,
                               ERRLST_TOP);

           IF STATUS &gt TMP_STATUS
              THEN TMP_STATUS = STATUS;
         END;

      F = F-&gtFIELD_NODE.NEXT_PTR;

   END;

   IF TMP_STATUS ^= 0
      THEN STATUS = TMP_STATUS;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*------------------------------------------------------------------*/
 /*                            PROCESS_FIELD                         */
 /*                                                                  */
 /* THIS PROCEDURE PROCESSES A SINGLE FIELD WITHIN THE IMPORT RECORD.*/
 /* THE VALUE WITHIN THE IMPORT RECORD IS FETCHED AND IF AN EDIT IS  */
 /* REQUIRED IT IS PERFORMED.                                        */
 /* THE VALUE IS SAVED IN THE FIELD_NODE, ONCE THE EDITS ARE DONE.   */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     IMP_RECORD - THE IMPORT RECORD.                              */
 /*                                                                  */
 /*     OFFSET    - OFFSET INTO THE IMPORT RECORD, WITH WHICH THE    */
 /*                 IS ASSOCIATED.                                   */
 /*                                                                  */
 /*     F         - POINTER TO A FIELD NODE.                         */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 12 - INVALID RECORD ENCOUNTERED IN IMPORT FILE.  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /* RETURNS POINTER;                                                 */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST.  ADD TABLE TO CALL    */
 /*               TP PROCESS EDITS.                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_FIELD: PROC (TABLE,BUF_PTR,IMP_RECORD,OFFSET,F,
                      RECORD_ID,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       IMP_RECORD        CHAR (*) VARYING,
       OFFSET            FIXED BIN (15),
       F                 POINTER,
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       VALUE             CHAR (512) VARYING,
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_FIELD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('IMPORT RECORD = ',TRIM(IMP_RECORD));
          PUT SKIP LIST ('TABLE    = ',TABLE);
          PUT SKIP LIST ('OFFSET   = ',OFFSET);
       %END;

   CALL PARSE_CSV_RECORD (IMP_RECORD,
                          OFFSET,
                          VALUE,
                          STATUS    );


   IF STATUS ^= 0
      THEN DO;
       STATUS = 12;
       ERRMSG = 'RECORD ID: '                        ||
                TRIM(RECORD_ID)                      ||
                ' ERROR IN SEARCHING FOR FIELD '     ||
                TRIM (F-&gtFIELD_NODE.VARIABLE)        ||
<A NAME="PROCESS_EDITS"></A>                ' AT OFFSET ' || TRIM (CHAR(OFFSET)) ||
                ' WITHIN THE IMPORT RECORD.';
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                       ERRMSG    );
       %IF DEBUGGER = 'ON'
           %THEN %DO;
             PUT SKIP LIST ('ERRMSG   = ',TRIM(ERRMSG));
          %END;

      END;

      ELSE DO;

        IF (F-&gtFIELD_NODE.EDIT_LIST_PTR ^= NULL) &amp
           (VALUE ^= ' ')
           THEN DO;

            CALL PROCESS_EDITS (F-&gtFIELD_NODE.EDIT_LIST_PTR,
                                VALUE,
                                RECORD_ID,
                                TABLE,
                                STATUS,
                                ERRLST_TOP                 );
           END;

        F-&gtFIELD_NODE.VALUE = VALUE;

       /* CHECK FOR BLANK VALUE AND REQUIRED FLAG */

        IF F-&gtFIELD_NODE.REQUIRED &amp
           (VALUE = ' ')
           THEN DO;
            STATUS = 10;
            ERRMSG = 'RECORD ID: '                     ||
                     TRIM(RECORD_ID)                   ||
                     ' ERROR IN VALUE FOR FIELD '      ||
                      TRIM (F-&gtFIELD_NODE.VARIABLE)    ||
                     '.  A BLANK WAS ENCOUNTERED' ||
                     ' AND THE FIELD IS SET TO &quotREQUIRED&quot.';
             CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                              ERRMSG    );
           END;

        IF STATUS = 0
           THEN CALL INSERT_VALUE (TABLE,
                                   BUF_PTR,
                                   F-&gtFIELD_NODE.VARIABLE,
                                   F-&gtFIELD_NODE.VAR_OFFSET,
                                   F-&gtFIELD_NODE.VAR_LENGTH,
                                   F-&gtFIELD_NODE.VALUE    );

     END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*------------------------------------------------------------------*/
 /*                            PROCESS_EDITS                         */
 /*                                                                  */
 /* THIS PROCEDURE PERFORMS ONE EDIT ON THE VALUE.                   */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     E         - POINTER TO EDIT NODE.                            */
 /*                                                                  */
 /*     VALUE     - VALUE BEING EDITED.                              */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 8  - DATA IN RECORD DID NOT PASS EDITS.          */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID AND TABLE TO PARAMETER LIST. PASS A      */
 /*               SEPERATE POINTER TO THE ERROR LIST TO THE VERIFY   */
 /*               PROCEDURES.                                        */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_EDITS: PROC (E,VALUE,RECORD_ID,TABLE,STATUS,ERRLST_TOP);


   DCL E                 POINTER,
       VALUE             CHAR (*) VARYING,
       RECORD_ID         CHAR (*) VARYING,
       TABLE             CHAR (8),
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       SUCCESS           BIT (1) INIT ('1'B),
       TRANSACTION       CHAR (32),
       ERRMSG            CHAR (132) VARYING,
       TMP_ERRLST        POINTER INIT (NULL),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_EDITS';

   %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('VALUE = ',TRIM(VALUE));
          PUT SKIP LIST ('EDIT TYPE = ',
                          E-&gtEDIT_NODE.EDIT_TYPE);
          CALL DUMP_EDIT_NODE  (E);
       %END;


  IF VALUE ^= ' '
     THEN DO;

   SELECT (E-&gtEDIT_NODE.EDIT_TYPE);
      WHEN ('D') DO;
        TRANSACTION = 'VERIFY DATE/TIME';
        CALL VERIFY_DATETIME_VALUE (VALUE,
                                    E-&gtEDIT_NODE.P3,
                                    E-&gtEDIT_NODE.P4,
                                    SUCCESS,
                                    TMP_ERRLST     );
      END;

      WHEN ('C') DO;
        TRANSACTION = 'VERIFY CODE';
        CALL VERIFY_CODE_VALUE (VALUE,
                                E-&gtEDIT_NODE.P1,
                                SUCCESS,
                                TMP_ERRLST      );
      END;

      WHEN ('V') DO;
        TRANSACTION = 'VERIFY VALUE';
        CALL VERIFY_VALUE_IS_IN_LIST (VALUE,
                                      E-&gtEDIT_NODE.P8,
                                      SUCCESS,
                                      TMP_ERRLST     );
      END;

      WHEN ('I') DO;
        TRANSACTION = 'VERIFY INTEGER';
        CALL VERIFY_INTEGER_VALUE (VALUE,
                                   E-&gtEDIT_NODE.P3,
                                   E-&gtEDIT_NODE.P6,
                                   E-&gtEDIT_NODE.P4,
                                   SUBSTR(E-&gtEDIT_NODE.P2,1,1),
                                   SUCCESS,
                                   TMP_ERRLST          );
      END;

      WHEN ('R') DO;
        TRANSACTION = 'VERIFY REAL';
        CALL VERIFY_REAL_VALUE (VALUE,
                                E-&gtEDIT_NODE.P3,
                                E-&gtEDIT_NODE.P4,
                                E-&gtEDIT_NODE.P6,
                                E-&gtEDIT_NODE.P7,
<A NAME="DETERMINE_KEY_VALUE"></A>                                SUCCESS,
                                TMP_ERRLST       );

      END;

      OTHERWISE DO;
       STATUS = 16;
       ERRMSG = 'RECORD ID: '                                   ||
                TRIM(RECORD_ID)                                 ||
                ' TABLE: '                                      ||
                TRIM(TABLE)                                     ||
                ' ERROR IN EDIT TYPE, INVALID CODE ENCOUNTERED' ||
                ' INTERNAL CODE ENCOUNTERED '                   ||
                 TRIM (E-&gtEDIT_NODE.EDIT_TYPE)                  ||
                 '.';
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                       ERRMSG    );
      END;
   END;

  END; /* IF NOT A BLANK */

   IF STATUS = 0 &amp
      ^SUCCESS
      THEN DO;

       STATUS = 8;
       ERRMSG = TMP_ERRLST-&gtERROR_MESSAGE_NODE.MESSAGE;
       ERRMSG = 'RECORD ID: '     ||
                TRIM(RECORD_ID)   ||
                ' TABLE: '        ||
                TRIM(TABLE)       ||
                ERRMSG;

       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                       ERRMSG    );

       FREE TMP_ERRLST-&gtERROR_MESSAGE_NODE;
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

  END PROCESS_EDITS;

 END PROCESS_FIELD;

 END PROCESS_FIELD_LIST;

 /*------------------------------------------------------------------*/
 /*                         DETERMINE_KEY_VALUE                      */
 /*                                                                  */
 /* THIS PROCEDURE WILL SUBSTRING THE BUF_PTR-&gtBUFFER STARTING AT    */
 /* AN OFFSET OF 1, FOR A LENGTH OF KEY_LENGTH.  IT WILL THEN LOOP   */
 /* THROUGH THE KEY_FIELDS ASSIGNING ALL THE VALUES FROM             */
 /*  BUF_PTR-&gtBUFFER.                                                */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     KEY_VALUE - RETURNED, THE KEY VALUE.                         */
 /*                                                                  */
 /*     KEY_LEN   - THE TOTAL LENGTH OF THE PRIMARY KEY.             */
<A NAME="ADD_RECORD"></A> /*                                                                  */
 /*     KEY_PTR   - POINTER TO LIST OF KEYS.                         */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST.                       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DETERMINE_KEY_VALUE: PROC (TABLE,BUF_PTR,KEY_VALUE,KEY_LEN,
                            KEY_PTR,RECORD_ID,STATUS,ERRLST_TOP);


   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       KEY_VALUE         CHAR (*) VARYING,
       KEY_LEN           FIXED BIN (15),
       KEY_PTR           POINTER,
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       CUR_PTR           POINTER,
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DETERMINE_KEY_VALUE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

  KEY_VALUE = SUBSTR(BUF_PTR-&gtBUFFER,1,KEY_LEN);

  CUR_PTR = KEY_PTR;
  DO WHILE (CUR_PTR ^= NULL);
     CUR_PTR-&gtKEY_FIELD_NODE.VALUE =
                         SUBSTR(BUF_PTR-&gtBUFFER,
                                CUR_PTR-&gtKEY_FIELD_NODE.VAR_OFFSET,
                                CUR_PTR-&gtKEY_FIELD_NODE.VAR_LENGTH);

     CUR_PTR = CUR_PTR-&gtKEY_FIELD_NODE.NEXT_PTR;
   END;


  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('KEY = ',TRIM(KEY_VALUE));
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END DETERMINE_KEY_VALUE;

 /*------------------------------------------------------------------*/
 /*                             ADD_RECORD                           */
 /*                                                                  */
 /* THIS PROCEDURE PERFORMS THE ADD TRANSACTION.  FIRST IT CHECKS TO */
 /* ENSURE THAT THE RECORD IS NOT IN THE DATABASE.  IF THIS CHECK    */
 /* PASSES, IT WILL THEN ADD THE RECORD.                             */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     R         - POINTER TO RECORD NODE.                          */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 ADD_RECORD: PROC (TABLE,R,KEY_VALUE,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       R                 POINTER,
       KEY_VALUE         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       FOUND             BIT (1) INIT ('0'B),
       TMPBUFFER         CHAR (4096),
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'ADD_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;
 /*
  * IF R-&gtRECORD_NODE.LRECL ^= R-&gtRECORD_NODE.TOT_REC_SIZE
  *    THEN DO;
  *      STATUS = 16;
  *      ERRMSG = 'LOGICAL RECORD LENGTH FOR TABLE: ' ||
<A NAME="UPDATE_RECORD"></A>  *               TRIM(TABLE)                         ||
  *               ' IS DIFFERENT FROM  '              ||
  *               'TOTAL LENGTH OF FIELDS.'           ||
  *               ' LRECL = '                         ||
  *               TRIM(CHAR(R-&gtRECORD_NODE.LRECL))    ||
  *               ' TOTAL FIELD LENGTH = '            ||
  *               TRIM(CHAR(R-&gtRECORD_NODE.TOT_REC_SIZE));
  *      CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
  *                                       ERRMSG      );
  *    END;
  *
  *    ELSE DO;
  */

       /* SAVE THE BUFFER CONTENTS. */

        TMPBUFFER = R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER;

        /* PERFORM CHECK */

        FOUND = CHECK_FOR_RECORD (TABLE,KEY_VALUE,
                                  R-&gtRECORD_NODE.KEY_SIZE,
                                  R-&gtRECORD_NODE.RECORD_ID,
                                  STATUS,ERRLST_TOP      );

        IF ^FOUND
            THEN DO;

              /* RESTORE THE ORIGINAL BUFFER */

              R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER  = TMPBUFFER;
              CALL PERFORM_WRITE (TABLE,KEY_VALUE,
                                  R-&gtRECORD_NODE.BUFFER_PTR,
                                  R-&gtRECORD_NODE.TOT_REC_SIZE,
                                  R-&gtRECORD_NODE.RECORD_ID,
                                  STATUS,ERRLST_TOP);
            END;
            ELSE DO;
              STATUS = 10;
              ERRMSG = 'RECORD ID: '                      ||
                        TRIM(R-&gtRECORD_NODE.RECORD_ID)    ||
                       ' TABLE: '                         ||
                       TRIM(TABLE)                        ||
                       'RECORD ALREADY EXISTS IN TABLE. ' ||
                       'KEY VALUES: '                     ||
                       TRIM(KEY_VALUE);
              CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                               ERRMSG    );
            END;

  /*    END;  IF LREC = TOT REC SIZE */

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END ADD_RECORD;

 /*------------------------------------------------------------------*/
 /*                       UPDATE_RECORD                              */
 /*                                                                  */
 /* THIS PROCEDURE PERFORMS THE UPDATE TRANSACTION.  FIRST IT CHECKS */
 /* TO ENSURE THAT THE RECORD IS IN THE DATABASE.  ONLY IF IT IS     */
 /* FOUND WILL IT PERFORM THE UPDATE.  ONCE THE RECORD IS READ,      */
 /* BOTH THE INIT LIST AND FIELD LIST WILL NEED TO BE TRAVERSED TO   */
 /* REINSTALL THE VALUES INTO THE BUFFER BEFORE THE WRITE IS         */
 /* PERFORMED.                                                       */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     IDRPTR    - POINTER TO RECORD NODE.                          */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 10 - TRANSACTION ERROR ENCOUNTERED.              */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST OF CALLED PROCEDURES.  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 UPDATE_RECORD: PROC (TABLE,R,KEY_VALUE,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       R           POINTER,
       KEY_VALUE         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       TMPBUFFER         CHAR (4096),
       FOUND             BIT (1) INIT ('0'B),
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'UPDATE_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   /* SAVE THE BUFFER CONTENTS. */

   TMPBUFFER = R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER;


 /*   IF R-&gtRECORD_NODE.LRECL = R-&gtRECORD_NODE.TOT_REC_SIZE
  *    THEN TMPBUFFER = R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER;
  */
   FOUND = CHECK_FOR_RECORD (TABLE,KEY_VALUE,
                             R-&gtRECORD_NODE.KEY_SIZE,
                             R-&gtRECORD_NODE.RECORD_ID,
                             STATUS,ERRLST_TOP              );

   IF FOUND
      THEN DO;

   /* RESTORE THE BUFFER CONTENTS. */

   /*    IF R-&gtRECORD_NODE.LRECL = R-&gtRECORD_NODE.TOT_REC_SIZE
    *      THEN R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER = TMPBUFFER;
    *      ELSE DO;
    */

           IF R-&gtRECORD_NODE.INIT_LIST_PTR ^= NULL
              THEN
<A NAME="DELETE_RECORD"></A>                CALL PROCESS_INIT_LIST (TABLE,
                                        R-&gtRECORD_NODE.BUFFER_PTR,
                                        R-&gtRECORD_NODE.INIT_LIST_PTR,
                                        R-&gtRECORD_NODE.RECORD_ID,
                                        STATUS,
                                        ERRLST_TOP                  );

           CALL REPROCESS_FIELD_LIST (TABLE,
                                      R-&gtRECORD_NODE.BUFFER_PTR,
                                      R-&gtRECORD_NODE.FIELD_LIST_PTR,
                                      STATUS,
                                      ERRLST_TOP                   );
    /*     END; */

        CALL PERFORM_WRITE (TABLE,KEY_VALUE,
                            R-&gtRECORD_NODE.BUFFER_PTR,
                            R-&gtRECORD_NODE.TOT_REC_SIZE,
                            R-&gtRECORD_NODE.RECORD_ID,
                            STATUS,ERRLST_TOP);

      END;
      ELSE DO;
   /*
    *    IF R-&gtRECORD_NODE.LRECL = R-&gtRECORD_NODE.TOT_REC_SIZE
    *      THEN DO;
    */
            ERRMSG = 'RECORD ID: '                      ||
                     TRIM(R-&gtRECORD_NODE.RECORD_ID)     ||
                     ' TABLE: '                         ||
                     TRIM(TABLE)                        ||
                     'RECORD DID NOT EXIST IN TABLE: '  ||
                      '.  ADDING RECORD.  KEY VALUES: ' ||
                     TRIM(KEY_VALUE);
            CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                             ERRMSG    );
            R-&gtRECORD_NODE.BUFFER_PTR-&gtBUFFER = TMPBUFFER;
            CALL PERFORM_WRITE (TABLE,KEY_VALUE,
                                R-&gtRECORD_NODE.BUFFER_PTR,
                                R-&gtRECORD_NODE.TOT_REC_SIZE,
                                R-&gtRECORD_NODE.RECORD_ID,
                                STATUS,ERRLST_TOP);
     /*
      *    END;
      *    ELSE DO;
      *      STATUS = 16;
      *       ERRMSG = 'RECORD DID NOT EXIST IN TABLE: ' ||
      *               TRIM(TABLE)                       ||
      *                '.';
      *      CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
      *                                       ERRMSG    );
      *      ERRMSG = 'KEY VALUES: ' ||
      *               TRIM(KEY_VALUE);
      *      CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
      *                                       ERRMSG    );
      *    END;
      */

      END; /* IF RECORD NOT FOUND */

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END UPDATE_RECORD;

 /*------------------------------------------------------------------*/
 /*                          DELETE_RECORD                           */
 /*                                                                  */
 /* THIS PROCEDURE PERFORMS THE DELETE TRANSACTION.  IT USES A BEGIN */
 /* BLOCK TO CREATE A FIXED LENGTH KEY BEFORE CALLING ITDELETE.      */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     KEY_LEN   - THE LENGTH OF THE PRIMARY KEY.                   */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST.                       */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DELETE_RECORD: PROC (TABLE,KEY_VALUE,KEY_LEN,RECORD_ID,
                      STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       KEY_VALUE         CHAR (*) VARYING,
<A NAME="CHECK_FOR_RECORD"></A>       KEY_LEN           FIXED BIN (15),
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ITRC              FIXED BIN (15) INIT (0),
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DELETE_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   BEGIN;

     DCL FIXED_KEY   CHAR(KEY_LEN);

     FIXED_KEY = SUBSTR(KEY_VALUE,1,KEY_LEN);
     ITRC      = ITDEL (TABLE, FIXED_KEY, '0','');


 /* DEBUGGING */
  %IF DEBUGGER = 'ON'
       %THEN %DO;
     PUT SKIP LIST ('ITDEL WAS BEING CALLED WITH TABLE ',
                     TABLE);
     PUT SKIP LIST ('THE VARYING KEY VALUE IS : ',TRIM(KEY_VALUE));
     PUT SKIP LIST ('THE KEY SIZE IS: ',KEY_LEN);
     PUT SKIP LIST ('THE FIXED KEY VALUE IS   : ',TRIM(FIXED_KEY));
       %END;

   END;

   IF ITRC ^= 0
      THEN DO;
       IF ITRC = 8
          THEN DO;
            STATUS = 10;
            ERRMSG = 'RECORD ID: '                ||
                     TRIM(RECORD_ID)              ||
                     ' TABLE: '                   ||
                     TRIM(TABLE)                  ||
                     'DELETE FAILED, FOR TABLE: ' ||
                     '.  RECORD WAS NOT FOUND.';
           END;
            ELSE DO;
             STATUS = 16;
             ERRMSG = 'RECORD ID: '                  ||
                      TRIM(RECORD_ID)                ||
                      ' TABLE: '                     ||
                      TRIM(TABLE)                    ||
                      'DELETE FAILED, FOR TABLE: '   ||
                      TRIM(TABLE)                    ||
                      '.  ITRC = ' || TRIM(CHAR(ITRC));
            END;

       ERRMSG = TRIM(ERRMSG) || 'KEY VALUES: ' ||
                 TRIM(KEY_VALUE);
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DELETE_RECORD;

 /*------------------------------------------------------------------*/
 /*                       CHECK_FOR_RECORD                           */
 /*                                                                  */
 /* THIS PROCEDURE CHECKS FOR THE PRESENCE OF A RECORD WITH ITREAD.  */
 /* IT USES A BEGIN BLOCK TO CREATE A FIXED LENGTH KEY BEFORE        */
 /* CALLING ITREAD.  IF THE RECORD WAS FOUND IT SETS THE FOUND BIT   */
 /* TRUE('1'B), ELSE IF IT WAS NOT FOUND IT SETS IT TO FALSE ('0'B). */
 /* IF AN ERROR WAS DETECTED IT SETS THE STATUS TO INDICATE THAT     */
 /* AN ERROR OCCURRED.                                               */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     KEY_LEN   - LENGTH OF PRIMARY KEY.                           */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST OF CALLED PROCEDURES.  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 CHECK_FOR_RECORD: PROC (TABLE,KEY_VALUE,KEY_LEN,RECORD_ID,
                         STATUS,ERRLST_TOP) RETURNS (BIT(1));

   DCL TABLE             CHAR (8),
       KEY_VALUE         CHAR (*) VARYING,
       KEY_LEN           FIXED BIN (15),
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ITRC              FIXED BIN (15) INIT (0),
       FOUND             BIT (1) INIT ('1'B),
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'CHECK_FOR_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   BEGIN;


     DCL FIXED_KEY   CHAR(KEY_LEN);

     FIXED_KEY = SUBSTR(KEY_VALUE,1,KEY_LEN);

     ITRC = ITREAD (TABLE, FIXED_KEY,'0','');

   END;

   IF ITRC ^= 0 &amp
      ITRC ^= 8
      THEN DO;
       STATUS = 16;
       ERRMSG = 'RECORD ID: '             ||
                TRIM(RECORD_ID)           ||
                ' TABLE: '                ||
                TRIM(TABLE)               ||
                ' ITREAD FAILED, '        ||
                '.  ITRC = '              ||
                TRIM(CHAR(ITRC))          ||
                'KEY VALUES: '            ||
                 TRIM(KEY_VALUE);
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                        ERRMSG    );
      END;

   IF ITRC = 0
      THEN FOUND = '1'B;
      ELSE FOUND = '0'B;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN (FOUND);

 END CHECK_FOR_RECORD;
<A NAME="PROCESS_INIT_LIST"></A>
 /*------------------------------------------------------------------*/
 /*                         PERFORM_WRITE                            */
 /*                                                                  */
 /* THIS PROCEDURE PERFORMS THE WRITE FOR BOTH THE UPDATE AND ADD    */
 /* TRANSACTIONS.                                                    */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO THE RECORD BUFFER.                    */
 /*                                                                  */
 /*     BUFFER_SIZE - TOTAL SIZE OF THE BUFFER.                      */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST OF CALLED PROCEDURES.  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PERFORM_WRITE: PROC (TABLE,KEY_VALUE,BUF_PTR,
                      BUFFER_SIZE,RECORD_ID,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       KEY_VALUE         CHAR (*) VARYING,
       BUF_PTR           POINTER,
       BUFFER_SIZE       FIXED BIN (15),
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       ITRC              FIXED BIN (15) INIT (0),
       ERRMSG            CHAR (132) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PERFORM_WRITE';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

  ITRC = ITWRITE (TABLE, ' ');

 /*DEBUGGING */

  %IF DEBUGGER = 'ON'
       %THEN %DO;
     PUT SKIP LIST ('ITWRITE WAS BEING CALLED WITH TABLE ',
                     TABLE);
     PUT SKIP LIST ('THE KEY VALUE IS : ',TRIM(KEY_VALUE));
     CALL DUMP_RECORD_BUFFER (TABLE,BUF_PTR,BUFFER_SIZE);
<A NAME="REPROCESS_FIELD_LIST"></A>       %END;

 /* END OF DEBUGGING CODE */


   IF ITRC ^= 0 &amp
      ITRC ^= 8
      THEN DO;
       STATUS = 16;
       ERRMSG = 'RECORD ID: '          ||
                TRIM(RECORD_ID)        ||
                ' TABLE: '             ||
                TRIM(TABLE)            ||
                ' ITWRITE FAILED, '    ||
                '.  ITRC = '           ||
                TRIM(CHAR(ITRC))       ||
                'KEY VALUES: '         ||
                TRIM(KEY_VALUE);
       CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                       ERRMSG    );
      END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END PERFORM_WRITE;

 /*------------------------------------------------------------------*/
 /*                        PROCESS_INIT_LIST                         */
 /*                                                                  */
 /* THIS PROCEDURE LOADS THE INITIALIZE VALUES INTO THE TABLE RECORD */
 /* BUFFER.                                                          */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     IDIPTR    - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
<A NAME="INSERT_VALUE"></A> /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*    04/03/95:  CHANGED THE ERROR REPORTING TO ALWAYS PLACE THE    */
 /*               RECORD ID OF THE IMPORT RECORD FIRST.  ADD THE     */
 /*               RECORD ID TO PARAMETER LIST OF CALLED PROCEDURES.  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 PROCESS_INIT_LIST: PROC (TABLE,BUF_PTR,IDIPTR,RECORD_ID,
                          STATUS,ERRLST_TOP);
   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       IDIPTR            POINTER,
       RECORD_ID         CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       I                 POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PROCESS_INIT_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   I = IDIPTR;
   DO WHILE (I ^= NULL);

      CALL INSERT_VALUE (TABLE,
                         BUF_PTR,
                         I-&gtINIT_NODE.VARIABLE,
                         I-&gtINIT_NODE.VAR_OFFSET,
                         I-&gtINIT_NODE.VAR_LENGTH,
                         I-&gtINIT_NODE.VALUE    );

      I = I-&gtINIT_NODE.NEXT_PTR;

   END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END PROCESS_INIT_LIST;

 /*------------------------------------------------------------------*/
 /*                       REPROCESS_FIELD_LIST                       */
 /*                                                                  */
 /* THIS PROCEDURE RELOADS THE FIELD VALUES INTO THE TABLE RECORD    */
 /* BUFFER.                                                          */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     BUF_PTR   - POINTER TO RECORD BUFFER.                        */
 /*                                                                  */
 /*     IDFPTR    - POINTER TO LIST OF FIELD NODES.                  */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*     STATUS    - FIXED BIN (15) STATUS OF THE INITIALIZATION      */
 /*                 PROCESS.                                         */
 /*                 0  - SUCCESSFUL                                  */
 /*                 16 - SEVERE ERROR.                               */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/26/95                                                 */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 REPROCESS_FIELD_LIST: PROC (TABLE,BUF_PTR,IDFPTR,STATUS,ERRLST_TOP);

   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       IDFPTR            POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       R                 POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'REPROCESS_FIELD_LIST';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   R = IDFPTR;
   DO WHILE (R ^= NULL);

     IF ^R-&gtFIELD_NODE.IGNORE &amp
         ^R-&gtFIELD_NODE.CONTAINS_ACTION
          THEN CALL INSERT_VALUE (TABLE,
                                  BUF_PTR,
                                  R-&gtFIELD_NODE.VARIABLE,
                                  R-&gtFIELD_NODE.VAR_OFFSET,
                                  R-&gtFIELD_NODE.VAR_LENGTH,
                                  R-&gtFIELD_NODE.VALUE     );

      R = R-&gtFIELD_NODE.NEXT_PTR;

   END;

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END REPROCESS_FIELD_LIST;

 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*     TABLE     - THE NAME OF THE TABLE BEING INITIALIZED.         */
 /*                                                                  */
 /*     IDRPTR    - POINTER TO LIST OF RECORD NODES.                 */
 /*                                                                  */
 /*                                                                  */
 /*     KEY_VALUE - PRIMARY KEY OF IMPORT RECORD PROCESSED.          */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/19/95                                                 */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 INSERT_VALUE: PROC (TABLE,BUF_PTR,VARIABLE,OFFSET,VLENGTH,VALUE);

   DCL TABLE             CHAR (8),
       BUF_PTR           POINTER,
       VARIABLE          CHAR (8),
       OFFSET            FIXED BIN (15),
       VLENGTH            FIXED BIN (15),
       VALUE             CHAR (*) VARYING,

       LEN               FIXED BIN (15),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'INSERT_VALUE';

   %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('VARIABLE = ',VARIABLE);
          PUT SKIP LIST ('OFFSET   = ',OFFSET);
          PUT SKIP LIST ('LENGTH   = ',VLENGTH);
          PUT SKIP LIST ('LENGTH 0F VALUE = ',LENGTH(VALUE));
          PUT SKIP LIST ('VALUE    = ',TRIM(VALUE));
<A NAME="DUMP_RECORDS"></A>          IF TRIM(VALUE) = ' '
             THEN PUT SKIP LIST ('VALUE IS BLANK');
       %END;

   IF (VALUE = ' ')
      THEN SUBSTR(VALUE,1,VLENGTH) = ' ';

   IF LENGTH(VALUE) &lt VLENGTH
      THEN DO;
       LEN = LENGTH(VALUE);
       DO WHILE (LEN &lt VLENGTH);
          SUBSTR(VALUE,LEN+1,1) = ' ';
          LEN = LEN + 1;
       END;
      END;


   SUBSTR(BUF_PTR-&gtBUFFER,OFFSET,VLENGTH) =
                       SUBSTR(VALUE,1,VLENGTH);


  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('BUFFER SO FAR = ', TRIM(
                        SUBSTR(BUF_PTR-&gtBUFFER,1,VLENGTH+OFFSET)));
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
   END INSERT_VALUE;


 END PROCESS_IMPORT_FIELDS;

 END PROCESS_IMPORT_RECORD;

 END IMPORT_NEXT_CSV_RECORD;


 /*------------------------------------------------------------------*/
 /*               IMPORT DEFINITION DATA STRUCTURES                  */
 /*                                                                  */
 /* THIS MODULE INCLUDES ALL THE DATA STRUCTURES USED IN             */
 /* PROCESSING BOTH THE IMPORT DEFINITION FILE AND THE IMPORT CSV    */
 /* FILE.  IT IS COMMON AMONG BOTH THE INITIALIZE_CSV_IMPORT, THE    */
 /* IMPORT_NEXT_CSV_RECORD, AND THE END_CSV_IMPORT PROCEDURES.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/26/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/

 /* DECLARATIONS NEEDED BY THIS PROCEDURES */

 DCL 1 IMPORT_DEFINITION         BASED,
       2 RECORD_LIST_PTR         POINTER,
       2 LAST_RECORD_NODE_PTR    POINTER;

 DCL 1 RECORD_NODE               BASED,
       2 RECORD_ID               CHAR(80) VARYING,
       2 IGNORE                  BIT(1),
       2 TABLE                   CHAR(8),
       2 TABLE_OPEN              BIT(1),
       2 OPEN_OPTIONS            CHAR(80) VARYING,
       2 TRANSACTION             CHAR(1),
       2 ABORT_ON_ERROR          BIT(1),
       2 VALID_RECORDS           FIXED BIN (31),
       2 INVALID_RECORDS         FIXED BIN (31),
       2 KEY_SIZE                FIXED BIN (15),
       2 LRECL                   FIXED BIN (15),
       2 TOT_REC_SIZE            FIXED BIN (15),
       2 INIT_LIST_PTR           POINTER,
       2 FIELD_LIST_PTR          POINTER,
       2 KEY_FIELD_PTR           POINTER,
       2 BUFFER_PTR              POINTER,
       2 NEXT_PTR                POINTER;

 DCL 1 INIT_NODE           BASED,
       2 VARIABLE          CHAR(8),
       2 VALUE             CHAR(512) VARYING,
       2 VAR_OFFSET        FIXED BIN (15),
       2 VAR_LENGTH        FIXED BIN (15),
       2 NEXT_PTR          POINTER;

 DCL 1 KEY_FIELD_NODE      BASED,
       2 VARIABLE          CHAR(8),
       2 VALUE             CHAR (512) VARYING,
       2 VAR_OFFSET        FIXED BIN (15),
       2 VAR_LENGTH        FIXED BIN (15),
       2 NEXT_PTR          POINTER;

 DCL 1 FIELD_NODE          BASED,
       2 VARIABLE          CHAR(8),
       2 VALUE             CHAR (512) VARYING,
       2 VAR_OFFSET        FIXED BIN (15),
       2 VAR_LENGTH        FIXED BIN (15),
       2 IGNORE            BIT(1),
       2 CONTAINS_ACTION   BIT(1),
       2 CONTAINS_VALUE    BIT(1),
       2 REQUIRED          BIT(1),
       2 EDIT_LIST_PTR     POINTER,
       2 NEXT_PTR          POINTER;

<A NAME="DUMP_INIT_NODES"></A>
 DCL 1 EDIT_NODE           BASED,
       2 EDIT_TYPE         CHAR(1),
       2 P1                CHAR(80) VARYING,
       2 P2                CHAR(80) VARYING,
       2 P3                FIXED BIN (15),
       2 P4                FIXED BIN (15),
       2 P5                FIXED BIN (15),
       2 P6                BIT(1),
       2 P7                BIT(1),
       2 P8                POINTER,
       2 P9                POINTER;

 DCL 1 VALUE_LIST_NODE     BASED,
       2 VALUE             CHAR(80) VARYING,
       2 NEXT_PTR          POINTER;

 /* USED TO ALLOCATE BUFFER SPACE TO PASS TO THE */
 /* DB PRIMITIVES.                               */

 DCL BUFFER     CHAR (4096) BASED;


 /*******************************************************************/
 /*                                                                 */
 /*  DEBUGGING PROCEDURES USED TO DUMP THE CSV DATA STRUCTURES      */
 /*                                                                 */
 /*******************************************************************/

 /*------------------------------------------------------------------*/
 /*                           DUMP_RECORDS                           */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS THE ENTIRE CSV DATA STRUCTURES.             */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDR_PTR      - POINTER TO THE RECORD NODE.                     */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_RECORDS: PROC (IDR_PTR);


   DCL IDR_PTR           POINTER,

       PTR               POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_RECORDS';

   PUT SKIP(2) LIST ('--------- DUMPING THE RECORD NODES ---------');
   PTR = IDR_PTR;
   IF PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO RECORD NODES *****');

   DO WHILE (PTR ^= NULL);
      PUT SKIP LIST ('===== RECORD NODE =====');
<A NAME="DUMP_KEY_FIELDS"></A>      PUT SKIP LIST ('   RECORD ID: ',
                     TRIM(PTR-&gtRECORD_NODE.RECORD_ID));

      PUT SKIP LIST ('   IGNORE: ',
                     PTR-&gtRECORD_NODE.IGNORE);
      PUT SKIP LIST ('   TABLE: ',
                     TRIM(PTR-&gtRECORD_NODE.TABLE));
      PUT SKIP LIST ('   TABLE OPEN: ',
                     PTR-&gtRECORD_NODE.TABLE_OPEN);
      PUT SKIP LIST ('   OPEN_OPTIONS: ',
                     TRIM(PTR-&gtRECORD_NODE.OPEN_OPTIONS));
      PUT SKIP LIST ('   TRANSACTION: ',
                     PTR-&gtRECORD_NODE.TRANSACTION);
      PUT SKIP LIST ('   ABORT ON ERROR: ',
                     PTR-&gtRECORD_NODE.ABORT_ON_ERROR);
      PUT SKIP LIST ('   VALID RECORDS: ',
                     PTR-&gtRECORD_NODE.VALID_RECORDS);
      PUT SKIP LIST ('   INVALID RECORDS: ',
                     PTR-&gtRECORD_NODE.INVALID_RECORDS);
      PUT SKIP LIST ('   KEY SIZE: ',
                     PTR-&gtRECORD_NODE.KEY_SIZE);
      PUT SKIP LIST ('   LRECL: ',
                     PTR-&gtRECORD_NODE.LRECL);
      PUT SKIP LIST ('   TOTAL RECORD SIZE: ',
                     PTR-&gtRECORD_NODE.TOT_REC_SIZE);

      IF PTR-&gtRECORD_NODE.KEY_FIELD_PTR^= NULL
        THEN CALL DUMP_KEY_FIELDS
                        (PTR-&gtRECORD_NODE.KEY_FIELD_PTR);
        ELSE PUT SKIP LIST (' ==== NO KEY FIELDS ====');

      IF PTR-&gtRECORD_NODE.INIT_LIST_PTR ^= NULL
        THEN CALL DUMP_INIT_NODES
                            (PTR-&gtRECORD_NODE.INIT_LIST_PTR);
        ELSE PUT SKIP LIST (' ==== NO INIT NODES ====');

      IF PTR-&gtRECORD_NODE.FIELD_LIST_PTR ^= NULL
        THEN CALL DUMP_FIELD_NODES
                            (PTR-&gtRECORD_NODE.FIELD_LIST_PTR);
<A NAME="DUMP_EDIT_NODE"></A>        ELSE PUT SKIP LIST (' ==== NO FIELD NODES ====');

      PTR = PTR-&gtRECORD_NODE.NEXT_PTR;

      PUT SKIP LIST (' ');

      IF PTR = NULL
        THEN
         PUT SKIP LIST ('***** END OF RECORD NODES *****');
        ELSE
         PUT SKIP LIST ('------------------------------------------');

    END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_RECORDS;


 /*------------------------------------------------------------------*/
 /*                       DUMP_INIT_NODES                            */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS THE LIST OF INITIALIZE NODES.               */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDI_PTR      - POINTER TO A LIST OF INIT NODES.                */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_INIT_NODES: PROC (IDI_PTR);


   DCL IDI_PTR           POINTER,

       PTR               POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_INIT_NODES';

   PUT SKIP(2) LIST ('--------- DUMPING THE INIT NODES ---------');
   PTR = IDI_PTR;
   IF PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO INITIALIZE NODES *****');

   DO WHILE (PTR ^= NULL);
      PUT SKIP LIST ('===== INIT NODE =====');

      PUT SKIP LIST ('    VARIABLE: ',
                     PTR-&gtINIT_NODE.VARIABLE);

      PUT SKIP LIST ('    VALUE: ',
                     TRIM(PTR-&gtINIT_NODE.VALUE));

      PUT SKIP LIST ('    OFFSET: ',
                     PTR-&gtINIT_NODE.VAR_OFFSET);

      PUT SKIP LIST ('    LENGTH: ',
                     PTR-&gtINIT_NODE.VAR_LENGTH);

      PTR = PTR-&gtINIT_NODE.NEXT_PTR;

      PUT SKIP LIST (' ');

      IF PTR = NULL
        THEN
         PUT SKIP(2) LIST ('***** END OF INIT NODES *****');
        ELSE
         PUT SKIP LIST ('------------------------------------------');

    END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_INIT_NODES;

 /*------------------------------------------------------------------*/
 /*                        DUMP_KEY_FIELDS                           */
 /*                                                                  */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDK_PTR      - POINTER TO A LIST OF KEY FIELD NODES.           */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_KEY_FIELDS: PROC (IDK_PTR);


   DCL IDK_PTR           POINTER,

       PTR               POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_KEY_FIELDS';

   PUT SKIP(2) LIST ('--------- DUMPING THE KEY FIELDS ---------');
   PTR = IDK_PTR;
   IF PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO KEY FIELDS *****');

   DO WHILE (PTR ^= NULL);
      PUT SKIP LIST ('===== KEY FIELD NODE =====');

      PUT SKIP LIST ('    VARIABLE: ',
                     PTR-&gtKEY_FIELD_NODE.VARIABLE);

      PUT SKIP LIST ('    VALUE: ',
                     TRIM(PTR-&gtKEY_FIELD_NODE.VALUE));

      PUT SKIP LIST ('    OFFSET: ',
                     PTR-&gtKEY_FIELD_NODE.VAR_OFFSET);

      PUT SKIP LIST ('    LENGTH: ',
                     PTR-&gtKEY_FIELD_NODE.VAR_LENGTH);

      PTR = PTR-&gtKEY_FIELD_NODE.NEXT_PTR;

      PUT SKIP LIST (' ');

      IF PTR = NULL
        THEN
         PUT SKIP(2) LIST ('***** END OF KEY FIELDS *****');
        ELSE
         PUT SKIP LIST ('------------------------------------------');

    END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_KEY_FIELDS;
<A NAME="DUMP_RECORD_BUFFER"></A>
 /*------------------------------------------------------------------*/
 /*                       DUMP_FIELD_NODES                           */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS THE LIST OF FIELD NODES.                    */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDF_PTR      - POINTER TO LIST OF FIELD NODES.                 */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_FIELD_NODES: PROC (IDF_PTR);


   DCL IDF_PTR           POINTER,

       PTR               POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_FIELD_NODES';

   PUT SKIP(2) LIST ('--------- DUMPING THE FIELD NODES ---------');
   PTR = IDF_PTR;
   IF PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO FIELD NODES *****');

   DO WHILE (PTR ^= NULL);
      PUT SKIP LIST ('===== FIELD NODE =====');

      PUT SKIP LIST ('    VARIABLE: ',
                     PTR-&gtFIELD_NODE.VARIABLE);

      PUT SKIP LIST ('    VALUE: ',
                     TRIM(PTR-&gtFIELD_NODE.VALUE));

      PUT SKIP LIST ('    OFFSET: ',
                     PTR-&gtFIELD_NODE.VAR_OFFSET);

<A NAME="ADD_MESSAGE_TO_MESSAGE_LIST"></A>      PUT SKIP LIST ('    LENGTH: ',
                     PTR-&gtFIELD_NODE.VAR_LENGTH);

      PUT SKIP LIST ('    IGNORE: ',
                     PTR-&gtFIELD_NODE.IGNORE);

      PUT SKIP LIST ('    CONTAINS ACTION: ',
                     PTR-&gtFIELD_NODE.CONTAINS_ACTION);

      PUT SKIP LIST ('    CONTAINS VALUE: ',
                     PTR-&gtFIELD_NODE.CONTAINS_VALUE);

      PUT SKIP LIST ('    REQUIRED: ',
                     PTR-&gtFIELD_NODE.REQUIRED);

      IF PTR-&gtFIELD_NODE.EDIT_LIST_PTR ^= NULL
         THEN CALL DUMP_EDIT_NODE
                               (PTR-&gtFIELD_NODE.EDIT_LIST_PTR);
         ELSE PUT SKIP LIST ('===== NO EDITS =====');

      PTR = PTR-&gtFIELD_NODE.NEXT_PTR;

      PUT SKIP LIST (' ');
<A NAME="VERIFY_REAL_VALUE"></A>
      IF PTR = NULL
        THEN
         PUT SKIP(2) LIST ('***** END OF FIELD NODES *****');
        ELSE
         PUT SKIP LIST ('------------------------------------------');

    END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_FIELD_NODES;

 /*------------------------------------------------------------------*/
 /*                        DUMP_EDIT_NODE                            */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS AN EDIT NODE.                               */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDE_PTR      - POINTER TO AN EDIT NODE.                        */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_EDIT_NODE: PROC (IDE_PTR);


   DCL IDE_PTR           POINTER,

       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_EDIT_NODE';
<A NAME="VALIDATE_STRING"></A>
   PUT SKIP(2) LIST ('--------- DUMPING AN EDIT NODE ---------');

   IF IDE_PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO EDIT NODE *****');
      ELSE DO;
        PUT SKIP LIST ('    EDIT TYPE: ',
                       IDE_PTR-&gtEDIT_NODE.EDIT_TYPE);

       SELECT (IDE_PTR-&gtEDIT_NODE.EDIT_TYPE);
         WHEN ('D')
          DO;
            PUT SKIP LIST ('    INPUT FORMAT: ',
                           IDE_PTR-&gtEDIT_NODE.P3);
            PUT SKIP LIST ('    OUTPUT FORMAT: ',
                           IDE_PTR-&gtEDIT_NODE.P4);
          END;

         WHEN ('C')
          DO;
            PUT SKIP LIST ('    TABLE: ',
                           TRIM(IDE_PTR-&gtEDIT_NODE.P1));
          END;

         WHEN ('V')
          DO;
            CALL DUMP_VALUE_LIST (IDE_PTR-&gtEDIT_NODE.P8);
          END;

         WHEN ('I')
          DO;
            PUT SKIP LIST ('    LENGTH: ',
                           IDE_PTR-&gtEDIT_NODE.P3);
            PUT SKIP LIST ('    SIGNED: ',
                           IDE_PTR-&gtEDIT_NODE.P6);
            PUT SKIP LIST ('    JUSTIFY: ',
                           IDE_PTR-&gtEDIT_NODE.P4);
            PUT SKIP LIST ('    PAD CHARACTER: ',
                           TRIM (IDE_PTR-&gtEDIT_NODE.P2));
          END;

         WHEN ('R')
          DO;
            PUT SKIP LIST ('    PRECISION: ',
                           IDE_PTR-&gtEDIT_NODE.P3);
            PUT SKIP LIST ('    SCALE: ',
                           IDE_PTR-&gtEDIT_NODE.P4);
            PUT SKIP LIST ('    SIGNED: ',
                           IDE_PTR-&gtEDIT_NODE.P6);
            PUT SKIP LIST ('    FORMAT: ',
                           IDE_PTR-&gtEDIT_NODE.P7);
          END;

        OTHERWISE DO;
            PUT SKIP LIST ('    INVALID EDIT FORMAT');
       END;
     END; /* OF SELECT */

     PUT SKIP LIST (' ');

     PUT SKIP(2) LIST ('***** END OF EDIT NODE *****');

   END; /* END OF ELSE */

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_EDIT_NODE;

 /*------------------------------------------------------------------*/
 /*                        DUMP_VALUE_LIST                           */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS THE LIST OF VALUES.                         */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*                                                                  */
 /*   IDV_PTR      - POINTER TO A LIST OF VALUE NODES.               */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/22/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_VALUE_LIST: PROC (IDV_PTR);
<A NAME="COMPARE_NON_DECIMAL_LENGTH"></A>

   DCL IDV_PTR           POINTER,

       PTR               POINTER,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_VALUE_LIST';

   PUT SKIP(2) LIST ('--------- DUMPING THE VALUE NODES ---------');
   PTR = IDV_PTR;
   IF PTR = NULL
      THEN
        PUT SKIP LIST ('***** NO VALUE NODES *****');

   DO WHILE (PTR ^= NULL);
      PUT SKIP LIST ('===== VALUE LIST NODE =====');

      PUT SKIP LIST ('    VALUE: ',
                     TRIM(PTR-&gtVALUE_LIST_NODE.VALUE));

      PTR = PTR-&gtVALUE_LIST_NODE.NEXT_PTR;

      PUT SKIP LIST (' ');

      IF PTR = NULL
        THEN
         PUT SKIP(2) LIST ('***** END OF VALUE LIST NODES *****');
        ELSE
         PUT SKIP LIST ('------------------------------------------');

    END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_VALUE_LIST;

 /*------------------------------------------------------------------*/
 /*                        DUMP_RECORD_BUFFER                        */
 /*                                                                  */
 /* THIS PROCEDURE DUMPS A RECORD BUFFER.                            */
 /*                                                                  */
 /* PARAMETERS:                                                      */
<A NAME="VALIDATE_SIGN"></A> /*                                                                  */
 /*   BUF_PTR      - POINTER TO A BUFFER.                            */
 /*                                                                  */
 /*   BUF_LEN      - LENGTH OF BUFFER.                               */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/28/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 DUMP_RECORD_BUFFER: PROC (FILEID,BUF_PTR,BUF_LEN);


   DCL FILEID            CHAR (8),
       BUF_PTR           POINTER,
       BUF_LEN           FIXED BIN (15),

       STRING            CHAR (72),
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'DUMP_RECORD_BUFFER';

   /*--- RTD 3/3/95 - CHANGED FROM:                                ---*/
   /*---                                                           ---*/
   /*---     DCL FILE_BUFFER  CHAR(BUF_LEN) BASED,                 ---*/
   /*---                                                           ---*/
   /*---     TO:                                                   ---*/
   /*---                                                           ---*/
   /*---     DCL FILE_BUFFER  CHAR(4096)    BASED,                 ---*/
   /*---                                                           ---*/
<A NAME="FORMAT_STRING"></A>   /*---     BECAUSE IBM COMPILER DOES NOT ALLOW A VARIABLE FOR    ---*/
   /*---     THE LENGTH WHEN USING &quotBASED&quot.  ADDED SUBSTR TO       ---*/
   /*---     ASSIGNMENT BELOW.                                     ---*/

   BEGIN;
     DCL FILE_BUFFER  CHAR(4096)    BASED,
         BUFFER       CHAR(BUF_LEN) VARYING;

     IF BUF_PTR = NULL
        THEN BUFFER = '';
        ELSE BUFFER = TRIM(SUBSTR(BUF_PTR-&gtFILE_BUFFER,1,BUF_LEN));

        PUT SKIP LIST (' ');
        PUT SKIP LIST ('TABLE: ',FILEID);

        DO WHILE (BUFFER ^= '');

           IF LENGTH(BUFFER) &lt 61
              THEN STRING = '          &lt' ||
                            TRIM(BUFFER)        || '&gt';
              ELSE STRING = '          &lt' ||
                            SUBSTR(BUFFER,1,60) || '&gt';

           PUT SKIP LIST(STRING);

           IF LENGTH(BUFFER) &lt 61
              THEN BUFFER = '';
              ELSE BUFFER = SUBSTR(BUFFER,61);
        END;
   END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END DUMP_RECORD_BUFFER;

 /*-----------------------------------------------------------*/
 /*                 ADD_MESSAGE_TO_MESSAGE_LIST               */
 /*-----------------------------------------------------------*/
 ADD_MESSAGE_TO_MESSAGE_LIST:  PROC (MESSAGE_LIST_PTR,MESSAGE);

    DCL SAVE_SEGMENT                    CHAR (31),
        (M,LAST_M,MESSAGE_LIST_PTR)     POINTER,
<A NAME="VERIFY_INTEGER_VALUE"></A>        MESSAGE                         CHAR (*) VARYING;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'ADD_MESSAGE_TO_MESSAGE_LIST';

    M = MESSAGE_LIST_PTR;

    DO WHILE (M ^= NULL);
       LAST_M = M;
       M = M-&gtERROR_MESSAGE_NODE.NEXT_PTR;
    END;

    ALLOCATE ERROR_MESSAGE_NODE SET (M);
    M-&gtERROR_MESSAGE_NODE.MESSAGE  = MESSAGE;
    M-&gtERROR_MESSAGE_NODE.NEXT_PTR = NULL;

    IF MESSAGE_LIST_PTR = NULL
       THEN MESSAGE_LIST_PTR = M;
       ELSE LAST_M-&gtERROR_MESSAGE_NODE.NEXT_PTR = M;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END ADD_MESSAGE_TO_MESSAGE_LIST;

 /*------------------------------------------------------------*/
 /*          VERIFY_REAL_VALUE                                 */
 /*------------------------------------------------------------*/
 VERIFY_REAL_VALUE:  PROC(STRING,PRECISION,SCALE,SIGNED,FORMAT,
                             STATUS,MESSAGE_LIST_PTR);

    DCL SAVE_SEGMENT                 CHAR (31),
        STRING                       CHAR (*) VARYING,
        PRECISION                    FIXED BIN (15),
        SCALE                        FIXED BIN (15),
        SIGNED                       BIT (1),
        FORMAT                       BIT (1),
        STATUS                       BIT (1),
        MESSAGE_LIST_PTR             POINTER,
        ORIGINAL_LENGTH_STR          FIXED BIN (15) INIT (0),
        DECIMAL_FOUND                BIT (1) INIT ('1'B),
        RLENGTH_ACTUAL               FIXED BIN (15) INIT (0),
        SUBSTR                       BUILTIN,
        LENGTH                       BUILTIN;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VERIFY_REAL_VALUE';

    STATUS = '1'B;
<A NAME="VALIDATE_STRING"></A>    IF (STRING = ' ' | STRING = '')
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                            'THE REAL NUMBER TO BE VERIFIED WAS BLANK');
         STATUS = '0'B;
         SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
         RETURN;
       END;

    CALL VALIDATE_STRING;


     /* IF NO MISTAKES FOUND &amp FORMAT=1 THEN FORMAT THE VALUE*/
     IF STATUS = '1'B
       THEN
         IF FORMAT = '1'B
           THEN CALL FORMAT_STRING;

    /******************************************************************/
    /*                                                                */
    /* THIS PROCEDURE CHECKS TO MAKE SURE THAT THE STRING CONTAINS    */
    /* ONLY VALID CHARACTERS AND THAT IT ISN'T TOO LONG               */
    /*                                                                */
    /******************************************************************/

    VALIDATE_STRING: PROCEDURE;

        DCL   POSITION                     FIXED DEC (9),
              SAVE_SEGMENT                 CHAR (31);


    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VALIDATE_STRING';


    /* CHECK FOR EMBEDDED BLANKS */

     STRING = TRIM (STRING);

     /* THIS VERIFY HAS THE - IN IT SINCE SOMETIMES A - IS VALID*/

     POSITION = VERIFY (STRING, '-0123456789.');

     IF POSITION ^= 0
       THEN DO;
         IF SUBSTR (STRING,POSITION,1) = ' '
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                     'THERE IS A BLANK EMBEDDED IN THE REAL NUMBER');
             STATUS = '0'B;
           END;

           ELSE DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                      'THE CHARACTER ' || SUBSTR (STRING,POSITION,1) ||
                      ' IS NOT VALID IN A REAL NUMBER');
             STATUS = '0'B;
           END; /* ELSE */
       END; /* THEN */

     CALL VALIDATE_LENGTH;
     CALL VALIDATE_SIGN;

     SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END VALIDATE_STRING;

   /******************************************************************/
   /*                                                                */
   /* THIS PROCEDURE DETERMINES IF THE # SENT IN IN THE STRING       */
   /* PARAMETER IS TOO BIG                                           */
   /*                                                                */
   /******************************************************************/
<A NAME="FORMAT_STRING"></A>
   VALIDATE_LENGTH: PROCEDURE;

      DCL    I                            FIXED BIN (15) INIT (1),
             LLENGTH_ACTUAL               FIXED BIN (15) INIT (0),
             LLENGTH_ALLOWED              FIXED BIN (15) INIT (0),
             SAVE_SEGMENT                 CHAR (31);

      SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
      SHELL$MODULE_SEGMENT = 'VALIDATE_LENGTH';

      ORIGINAL_LENGTH_STR = LENGTH (STRING);
      /* CALCULATE THE NUMBER OF DIGITS TO THE LEFT OF THE DECIMAL  */
      /* TO MAKE SURE THAT THAT PART OF THE NUMBER IS NOT TOO LONG */

      DO WHILE (SUBSTR (STRING,I,1) ^= '.' &amp I &lt ORIGINAL_LENGTH_STR);
        I = I + 1;
      END; /* WHILE */

      IF SUBSTR (STRING,I,1) = '.'
        THEN LLENGTH_ACTUAL = I - 1;
        ELSE DO;
          DECIMAL_FOUND = '0'B;
          LLENGTH_ACTUAL = I;
        END; /* ELSE */

        LLENGTH_ALLOWED = PRECISION - SCALE;

      /* COMPARE THE LENGTH TO THE RIGHT OF THE DECIMAL TO SCALE */
      /* TO MAKE SURE THE # TO RIGHT OF DECIMAL IS NOT TOO LONG */
      IF DECIMAL_FOUND
        THEN
          CALL COMPARE_DECIMAL_LENGTH (LLENGTH_ACTUAL,LLENGTH_ALLOWED);
        ELSE CALL COMPARE_NON_DECIMAL_LENGTH (LLENGTH_ALLOWED);

      SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END VALIDATE_LENGTH;


   /******************************************************************/
   /*                                                                */
   /* THIS PROCEDURE COMPARES THE LENGTHS OF STRINGS WHICH CONTAIN   */
   /* A DECIMAL POINT                                                */
   /*                                                                */
   /******************************************************************/

   COMPARE_DECIMAL_LENGTH: PROC (LLENGTH_ACTUAL, LLENGTH_ALLOWED);

      DCL    LLENGTH_ACTUAL               FIXED BIN (15),
             LLENGTH_ALLOWED              FIXED BIN (15),
             SAVE_SEGMENT                 CHAR (31),
             RIGHT_OF_DEC_STR             CHAR (20) VARYING;

     SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
     SHELL$MODULE_SEGMENT = 'COMPARE_DECIMAL_LENGTH';

     /* CHECK THE STRING TO THE RIGHT OF THE FIRST DECIMAL POINT */
     /* TO MAKE SURE THERE ARE NO EXTRA DECIMAL POINTS.          */

     RIGHT_OF_DEC_STR = SUBSTR (STRING, LLENGTH_ACTUAL + 2);
     IF VERIFY ('.', RIGHT_OF_DEC_STR) = 0
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                'THERE ARE MULTIPLE DECIMAL POINTS IN THE ' ||
                'REAL NUMBER');
         STATUS = '0'B;
       END;

      /* COMPARE THE LENGTH TO THE RIGHT OF THE DECIMAL TO SCALE */
      /* TO MAKE SURE THE # TO RIGHT OF DECIMAL IS NOT TOO LONG */

     RLENGTH_ACTUAL = (ORIGINAL_LENGTH_STR - LLENGTH_ACTUAL) - 1;
<A NAME="VERIFY_DATETIME_VALUE"></A>
     IF RLENGTH_ACTUAL &gt SCALE
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                'THE NUMBER OF DIGITS TO THE RIGHT OF THE ' ||
                'DECIMAL POINT IS GREATER THAN THE MAXIMUM ALLOWED (' ||
                TRIM(CHAR(SCALE)) || ')');
         STATUS = '0'B;
       END;

     IF LLENGTH_ACTUAL &gt LLENGTH_ALLOWED
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                   'THE TOTAL NUMBER OF DIGITS TO THE LEFT OF THE ' ||
                   'DECIMAL POINT IS GREATER THAN THE MAXIMUM ' ||
                   'ALLOWED (' || TRIM(CHAR(LLENGTH_ALLOWED)) || ')' );
         STATUS = '0'B;
       END;

     SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END COMPARE_DECIMAL_LENGTH;



   /*****************************************************************/
   /*                                                               */
   /* THIS PROCEDURE COMPARES THE LENGTHS OF STRINGS WHICH DO NOT   */
   /* CONTAIN A DECIMAL POINT                                       */
   /*                                                               */
   /*****************************************************************/



   COMPARE_NON_DECIMAL_LENGTH: PROC (LLENGTH_ALLOWED);

     DCL      LLENGTH_ALLOWED              FIXED BIN (15),
              SAVE_SEGMENT                 CHAR (31);

     SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
     SHELL$MODULE_SEGMENT = 'COMPARE_NON_DECIMAL_LENGTH';

     /* COMPARE THE ORIGINAL STRING TO THE LEFT LENGTH ONLY SINCE */
     /* THE STRING DOES NOT HAVE A DECIMAL POINT. THERE MUST BE */
     /* ROOM TO ADD THE DECIMAL POINT AND THE SCALE # OF ZEROS TO */
     /* ITS RIGHT IF APPROPRIATE*/

     IF FORMAT
       THEN DO;
         IF ORIGINAL_LENGTH_STR &gt LLENGTH_ALLOWED
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                     'THE STRING IS LONGER THAN THE MAXIMUM ' ||
                     'ALLOWED (' || TRIM(CHAR(LLENGTH_ALLOWED)) ||
                     ')--THERE IS NOT ENOUGH SPACE TO ADD THE ' ||
                     'DECIMAL POINT AND DIGITS TO ITS RIGHT');
             STATUS = '0'B;
           END;
       END; /* IF FORMAT */
       ELSE
         IF ORIGINAL_LENGTH_STR &gt PRECISION
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                    'THE TOTAL NUMBER OF DIGITS IN THE STRING IS ' ||
                    'GREATER THAN THE MAXIMUM ALLOWED (' ||
                    TRIM(CHAR(PRECISION)) || ')');
             STATUS = '0'B;
           END;

     SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END COMPARE_NON_DECIMAL_LENGTH;


   /***************************************************************/
   /*                                                             */
   /* THIS PROCEDURE DETERMINES WHETHER ANY MINUS SIGNS IN        */
   /* THE STRING ARE OKAY.                                        */
   /*                                                             */
   /***************************************************************/

   VALIDATE_SIGN: PROC;

     DCL SAVE_SEGMENT                 CHAR (31);

     SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
     SHELL$MODULE_SEGMENT = 'VALIDATE_SIGN';

     IF SIGNED = '0'B  /* MINUS SIGNS ARE INVALID */
       THEN DO;
         IF VERIFY ('-', STRING) = 0
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                         'THERE IS AN INVALID MINUS SIGN IN ' ||
                         'THE REAL NUMBER');
             STATUS = '0'B;
            END;
       END;

       ELSE IF SIGNED = '1'B  /*MINUS SIGNS VALID AT FRONT OF # ONLY */
         THEN DO;
           IF VERIFY ('-', SUBSTR(STRING,2)) = 0
              THEN DO;
                CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                         'THERE IS A MINUS SIGN EMBEDDED ' ||
                         'IN THE REAL NUMBER');
                STATUS = '0'B;
              END;
         END;

     SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END VALIDATE_SIGN;

   /**************************************************************/
   /*                                                            */
   /* THIS PROCEDURE FORMATS THE STRING BY RIGHT JUSTIFYING IT   */
   /* AND LEFT PADDING IT WITH BLANKS &amp RIGHT PADDING IT WITH    */
   /* ZEROES BASED ON THE PRECISION AND SCALE                    */
   /*                                                            */
   /**************************************************************/

   FORMAT_STRING: PROCEDURE;

      DCL NUM_TO_LEFT_PAD         FIXED BIN (15) INIT(0),
          NUM_TO_RIGHT_PAD        FIXED BIN (15) INIT(0),
          SAVE_SEGMENT            CHAR (31);

      SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
      SHELL$MODULE_SEGMENT = 'FORMAT_STRING';

      NUM_TO_RIGHT_PAD = SCALE - RLENGTH_ACTUAL;

      IF (^DECIMAL_FOUND &amp SCALE &gt 0)
        THEN STRING = STRING || '.';

      DO WHILE (NUM_TO_RIGHT_PAD &gt=1);
        STRING = STRING || '0';
        NUM_TO_RIGHT_PAD = NUM_TO_RIGHT_PAD - 1;
      END;

      /* IF THERE IS NO DECIMAL POINT IN THE FINAL STRING, */
      /* PAD WITH ONE MORE BLANK THAN IF THERE IS TO BE A  */
      /* DECIMAL IN THE FINAL STRING                       */
      IF SCALE &gt 0
        THEN NUM_TO_LEFT_PAD = (PRECISION + 1) - LENGTH (STRING);
        ELSE IF SCALE = 0
            THEN NUM_TO_LEFT_PAD = PRECISION - ORIGINAL_LENGTH_STR;

      DO WHILE (NUM_TO_LEFT_PAD &gt=1);
        STRING = ' ' || STRING;
        NUM_TO_LEFT_PAD = NUM_TO_LEFT_PAD - 1;
      END;

      SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END FORMAT_STRING;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END VERIFY_REAL_VALUE;


 /*------------------------------------------------------------*/
 /*          VERIFY_INTEGER_VALUE                              */
 /*------------------------------------------------------------*/
 VERIFY_INTEGER_VALUE:  PROC(STRING,ILENGTH,SIGNED,JUSTIFY,PAD_CHAR,
                             STATUS,MESSAGE_LIST_PTR);

    DCL SAVE_SEGMENT                 CHAR (31),
        STRING                       CHAR (*) VARYING,
        ILENGTH                      FIXED BIN (15),
        SIGNED                       BIT (1),
        JUSTIFY                      FIXED BIN (15),
        PAD_CHAR                     CHAR (1),
        STATUS                       BIT (1),
        MESSAGE_LIST_PTR             POINTER,
        POSITION                     FIXED DEC (9),
        SUBSTR                       BUILTIN,
        LENGTH                       BUILTIN;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VERIFY_INTEGER_VALUE';

    STATUS = '1'B;
    IF STRING = ' '
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                                'THE INTEGER TO BE VERIFIED WAS BLANK');
         STATUS = '0'B;
         SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
         RETURN;
       END;

    CALL VALIDATE_STRING;

     /* JUSTIFY THE VALUE TO THE LENGTH SPECIFIED IF JUSTIFY = 1 OR 2 */
     IF STATUS = '1'B
       THEN
         IF (JUSTIFY = 1 | JUSTIFY = 2)
           THEN CALL FORMAT_STRING;
           ELSE
             IF JUSTIFY ^= 0
               THEN DO;
                 CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                        'INVALID VALUE SENT FOR THE JUSTIFY PARAMETER');
                 STATUS = '0'B;
               END;

    /**************************************************************/
    /*                                                            */
    /* THIS PROCEDURE CHECKS TO MAKE SURE THAT THE STRING         */
    /* CONTAINS ONLY VALID CHARACTERS AND THAT IT ISN'T TOO LONG  */
    /*                                                            */
    /**************************************************************/

    VALIDATE_STRING: PROCEDURE;

    DCL SAVE_SEGMENT                 CHAR (31);

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VALIDATE_STRING';

    /* CHECK FOR EMBEDDED BLANKS */
     STRING = TRIM (STRING);

     /* THIS VERIFY HAS THE - IN IT SINCE SOMETIMES A - IS VALID*/
     POSITION = VERIFY (STRING, '-0123456789');


     IF POSITION ^= 0
       THEN DO;
         IF SUBSTR (STRING,POSITION,1) = ' '
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                     'THERE IS A BLANK EMBEDDED IN THE INTEGER');
             STATUS = '0'B;
           END;

           ELSE DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                          'THE CHARACTER ' ||
                          SUBSTR (STRING,POSITION,1) ||
                          ' IS NOT VALID IN AN INTEGER');
             STATUS = '0'B;
           END; /* ELSE */
       END; /* THEN */

     IF LENGTH (STRING) &gt ILENGTH
       THEN DO;
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                 'THE INTEGER IS LONGER THAN THE MAXIMUM ALLOWED');
         STATUS = '0'B;
       END;

     IF SIGNED = '0'B  /* MINUS SIGNS ARE INVALID */
       THEN DO;
         IF VERIFY ('-', STRING) = 0
           THEN DO;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                      'THERE IS AN INVALID MINUS SIGN IN ' ||
                      'THE INTEGER');
             STATUS = '0'B;
            END;
       END;
       ELSE IF SIGNED = '1'B
         THEN DO;
           IF VERIFY ('-', SUBSTR(STRING,2)) = 0
              THEN DO;
                CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                      'THERE IS AN INVALID MINUS SIGN IN ' ||
                      'THE INTEGER');
                STATUS = '0'B;
              END;
         END;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   END VALIDATE_STRING;



   /*************************************************************/
   /*                                                           */
   /* THIS PROCEDURE FORMATS THE STRING BY LEFT OR RIGHT        */
   /* JUSTIFYING IT AND PADDING IT WITH THE CHARACTER SENT IN   */
   /* VIA THE PAD_CHAR PARAM                                    */
   /*                                                           */
   /*************************************************************/

   FORMAT_STRING: PROCEDURE;

      DCL COUNTER                 FIXED BIN (15) INIT(0),
          NUM_TO_PAD              FIXED BIN (15) INIT(0),
          SAVE_SEGMENT            CHAR (31);

      SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
      SHELL$MODULE_SEGMENT = 'FORMAT_STRING';

      /* BY DEFAULT PAD THE STRING WITH BLANKS */
      IF PAD_CHAR = ''
        THEN PAD_CHAR = ' ';

      NUM_TO_PAD = ILENGTH - LENGTH (STRING);

      IF JUSTIFY = 1   /* LEFT JUSTIFY THE INTEGER */
        THEN
          DO WHILE (COUNTER &lt NUM_TO_PAD);
            STRING = STRING || PAD_CHAR;
            COUNTER = COUNTER + 1;
          END; /* DO WHILE */
        ELSE
          IF JUSTIFY = 2 /* RIGHT JUSTIFY THE INTEGER */
            THEN
              DO WHILE (COUNTER &lt NUM_TO_PAD);
                STRING = PAD_CHAR || STRING;
                COUNTER = COUNTER + 1;
              END; /* DO WHILE */

      SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

    END FORMAT_STRING;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END VERIFY_INTEGER_VALUE;


 /*-------------------------------------------------------------------*/
 /*                       VERIFY_DATETIME_VALUE                       */
 /*                                                                   */
 /*  THIS PROCEDURE VERIFIES THAT THE INPUT VALUE IS A VALID DATE AND */
 /*  FORMATS THE INPUT VALUE INTO THE SPECIFIED OUTPUT FORMAT.        */
 /*                                                                   */
 /*  PARAMETERS:                                                      */
 /*                                                                   */
 /*    STRING             STRING TO BE VERIFIED AND FORMATTED.        */
 /*                                                                   */
 /*    INPUT_FORMAT       FORMAT OF INPUT STRING:                     */
 /*                         1 - MM/DD/YY HH:MM:SS                     */
 /*                                                                   */
 /*    OUTPUT_FORMAT      FORMAT TO BE APPLIED TO THE INPUT STRING:   */
 /*                         1 - YYMMDD                                */
 /*                         2 - YYMMDDHHMMSS                          */
 /*                         3 - YYMMDDHHMM                            */
 /*                                                                   */
 /*    STATUS             FLAG INDICATING SUCCESS OR FAILURE OF EDIT. */
 /*                                                                   */
 /*    MESSAGE_LIST_PTR   POINTER TO A LIST OF ERROR MESSAGES.        */
 /*                                                                   */
 /*                                                                   */
 /*  SECTIONS THAT WILL REQUIRE MODIFICATION FOR THE SUPPORT OF       */
 /*  ADDITIONAL FORMATS ARE MARKED BY A COMMENT CONTAINING THE STRING */
 /*  &quotNEW_FORMATS&quot.  THE CURRENT LOGIC ASSUMES THAT ALL INPUT TIMES   */
 /*  ARE IN MILITARY FORMAT.                                          */
 /*                                                                   */
 /*  WRITTEN BY: RTD 2/21/95                                          */
 /*                                                                   */
 /*-------------------------------------------------------------------*/

 VERIFY_DATETIME_VALUE: PROC (STRING,INPUT_FORMAT,OUTPUT_FORMAT,
                              STATUS,MESSAGE_LIST_PTR);

   DCL STRING               CHAR(*) VARYING,
       INPUT_FORMAT         FIXED BIN (15),
       OUTPUT_FORMAT        FIXED BIN (15),
       STATUS               BIT(1),
       MESSAGE_LIST_PTR     POINTER;


   DCL DIGITS                  CHAR(10)    INIT ('1234567890'),

       (MONTH,DAY,YEAR,
        HOUR,MINUTE,SECOND)    CHAR(80) VARYING,
<A NAME="PARSE_TYPE_1_INPUT_DATETIME"></A>
       (MONTH_NUM,DAY_NUM,
        YEAR_NUM,HOUR_NUM,
        MINUTE_NUM,SECOND_NUM) FIXED BIN (15),

       INPUT_CONTAINS_TIME     BIT(1) INIT ('0'B),
       OUTPUT_CONTAINS_TIME    BIT(1) INIT ('0'B),
       DIGITS_IN_OUTPUT_YEAR   FIXED BIN (15),
       ZERO_PAD_YEAR           BIT(1),
       ZERO_PAD_MONTH          BIT(1),
       ZERO_PAD_DAY            BIT(1),
       ZERO_PAD_HOUR           BIT(1),
       ZERO_PAD_MINUTE         BIT(1),
       ZERO_PAD_SECOND         BIT(1),
       VALID_YEAR              BIT(1),
       VALID_MONTH             BIT(1),
       VALID                   BIT(1) INIT ('1'B),
       SAVE_SEGMENT       CHAR (31);

   DCL DAYS_IN_MONTH(12)   FIXED BIN (15) INIT (31,28,31,30,31,30,
                                                31,31,30,31,30,31 );

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'VERIFY_DATETIME_VALUE';


   /*--- HANDLE A BLANK INPUT STRING ---*/
   IF STRING = ''
      THEN DO;
        /*-- NEW_FORMATS - EXTEND THIS SECTION FOR NEW FORMATS ---*/
        SELECT;
          WHEN (OUTPUT_FORMAT = 1) STRING = '      ';
          WHEN (OUTPUT_FORMAT = 2) STRING = '            ';
          OTHERWISE
            CALL FATAL_ERROR ('PROGRAM',
                 'UNRECOGNIZED OUTPUT FORMAT (' ||
                 TRIM(CHARACTER(OUTPUT_FORMAT)) || ').');
        END;
        STATUS = '1'B;
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;


   /*--- DETERMINE THE ATTRIBUTES OF THE OUTPUT FORMAT ---*/

   /*-- NEW_FORMATS - EXTEND THIS SECTION FOR NEW FORMATS ---*/
   SELECT;

     WHEN (OUTPUT_FORMAT = 1)
       DO;
         OUTPUT_CONTAINS_TIME  = '0'B;
         DIGITS_IN_OUTPUT_YEAR = 2;
         ZERO_PAD_YEAR   = '1'B;
         ZERO_PAD_MONTH  = '1'B;
         ZERO_PAD_DAY    = '1'B;
         ZERO_PAD_HOUR   = '0'B;
         ZERO_PAD_MINUTE = '0'B;
         ZERO_PAD_SECOND = '0'B;
       END;

     WHEN (OUTPUT_FORMAT = 2)
       DO;
         OUTPUT_CONTAINS_TIME  = '1'B;
         DIGITS_IN_OUTPUT_YEAR = 2;
         ZERO_PAD_YEAR   = '1'B;
         ZERO_PAD_MONTH  = '1'B;
         ZERO_PAD_DAY    = '1'B;
         ZERO_PAD_HOUR   = '1'B;
         ZERO_PAD_MINUTE = '1'B;
         ZERO_PAD_SECOND = '1'B;
       END;

     WHEN (OUTPUT_FORMAT = 3)
       DO;
         OUTPUT_CONTAINS_TIME  = '1'B;
         DIGITS_IN_OUTPUT_YEAR = 2;
         ZERO_PAD_YEAR   = '1'B;
         ZERO_PAD_MONTH  = '1'B;
         ZERO_PAD_DAY    = '1'B;
         ZERO_PAD_HOUR   = '1'B;
         ZERO_PAD_MINUTE = '1'B;
         ZERO_PAD_SECOND = '0'B;
       END;

     OTHERWISE
       CALL FATAL_ERROR ('PROGRAM',
            'UNRECOGNIZED OUTPUT FORMAT ' ||
            TRIM(CHARACTER(OUTPUT_FORMAT)) || '.');
   END;


   /*--- PARSE THE INPUT STRING INTO ITS COMPONENTS ---*/

   /*-- NEW_FORMATS - CREATE A PARSE_TYPE_X_INPUT_DATETIME PROC ---*/
   /*---              FOR EACH NEW FORMAT ADDED.                ---*/
   SELECT;

     WHEN (INPUT_FORMAT = 1)
       CALL PARSE_TYPE_1_INPUT_DATETIME
            (STRING,MONTH,DAY,YEAR,HOUR,MINUTE,SECOND,
             INPUT_CONTAINS_TIME,VALID,MESSAGE_LIST_PTR);

     OTHERWISE
       CALL FATAL_ERROR ('PROGRAM',
            'UNRECOGNIZED INPUT FORMAT ' ||
            TRIM(CHARACTER(INPUT_FORMAT)) || '.');
   END;

   IF ^VALID
      THEN DO;
        STATUS = '0'B;
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;


   /*--- VERIFY THAT THE INPUT FIELDS ARE ALL INTEGERS ---*/
   IF ^IS_INTEGER (MONTH)
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'INVALID MONTH &quot' || MONTH || '&quot IN DATE &quot' ||
             STRING || '&quot.');
      END;

   IF ^IS_INTEGER (DAY)
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'INVALID DAY &quot' || DAY || '&quot IN DATE &quot' ||
             STRING || '&quot.');
      END;

   IF ^IS_INTEGER (YEAR)
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'INVALID YEAR &quot' || YEAR || '&quot IN DATE &quot' ||
             STRING || '&quot.');
      END;

   IF INPUT_CONTAINS_TIME
      THEN DO;

        IF ^IS_INTEGER (HOUR)
           THEN DO;
             VALID = '0'B;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                  'INVALID HOUR &quot' || HOUR || '&quot IN DATE &quot' ||
                  STRING || '&quot.');
           END;

        IF ^IS_INTEGER (MINUTE)
           THEN DO;
             VALID = '0'B;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                  'INVALID MINUTE &quot' || MINUTE || '&quot IN DATE &quot' ||
                  STRING || '&quot.');
           END;

        IF ^IS_INTEGER (SECOND)
           THEN DO;
             VALID = '0'B;
             CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                  'INVALID SECOND &quot' || SECOND || '&quot IN DATE &quot' ||
                  STRING || '&quot.');
           END;

      END; /* IF INPUT_CONTAINS_TIME */


  /*--- IF AN ERROR HAS BEEN DETECTED, DO NOT CONTINUE. ---*/
  IF ^VALID
     THEN DO;
       STATUS = '0'B;
       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
       RETURN;
     END;
<A NAME="IS_INTEGER"></A>


  /*--- IF THE INPUT STRING CONTAINS THE TIME, VERIFY IT, EVEN IF ---*/
  /*--- THE OUTPUT FORMAT DOES NOT CONTAIN ONE.  IF THE OUTPUT    ---*/
  /*--- FORMAT INCLUDES TIME AND THE INPUT STRING DID NOT, IT IS  ---*/
  /*--- AND ERROR.                                                ---*/

  IF OUTPUT_CONTAINS_TIME &amp ^INPUT_CONTAINS_TIME
     THEN DO;
       STATUS = '0'B;
       CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INPUT DATETIME &quot' || STRING ||
            '&quot DOES NOT INCLUDE THE TIME.  ' ||
            'TIME IS REQUIRED.');
       RETURN;
     END;

  IF INPUT_CONTAINS_TIME
     THEN DO;
       HOUR_NUM = FIXED(HOUR,15);
       DAY_NUM  = FIXED(DAY ,15);
       YEAR_NUM = FIXED(YEAR,15);
       MINUTE_NUM = FIXED(MINUTE,15);
       SECOND_NUM = FIXED(SECOND,15);
       IF HOUR_NUM &lt 0 | HOUR_NUM &gt 24
          THEN DO;
            VALID = '0'B;
            CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INVALID HOUR &quot' || HOUR || '&quot IN DATETIME &quot' ||
            STRING || '&quot.');
          END;

       IF MINUTE_NUM &lt 0 | MINUTE_NUM &gt 59
          THEN DO;
            VALID = '0'B;
            CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INVALID MINUTE &quot' || MINUTE || '&quot IN DATETIME &quot' ||
            STRING || '&quot.');
          END;

       IF SECOND_NUM &lt 0 | SECOND_NUM &gt 59
          THEN DO;
            VALID = '0'B;
            CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INVALID SECOND &quot' || SECOND || '&quot IN DATETIME &quot' ||
            STRING || '&quot.');
<A NAME="NEXT_TOKEN"></A>          END;

     END; /* IF INPUT_CONTAINS_TIME */


  /*--- VALIDATE THE YEAR ---*/
  YEAR_NUM = FIXED(YEAR,15);

  IF YEAR_NUM &lt 0 | YEAR_NUM &gt 9999
     THEN DO;
       VALID      = '0'B;
       VALID_YEAR = '0'B;
       CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INVALID YEAR &quot' || YEAR || '&quot IN DATETIME &quot' ||
            STRING || '&quot.');
     END;
     ELSE
       VALID_YEAR = '1'B;



  /*--- VALIDATE THE MONTH ---*/
  MONTH_NUM = FIXED(MONTH,15);

  IF MONTH_NUM &lt 1 | MONTH_NUM &gt 12
     THEN DO;
       VALID       = '0'B;
       VALID_MONTH = '0'B;
       CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
            'INVALID MONTH &quot' || MONTH || '&quot IN DATETIME &quot' ||
            STRING || '&quot.');
     END;
     ELSE
       VALID_MONTH = '1'B;


  /*--- IF MONTH AND YEAR ARE VALID, VALIDATE THE DAY ---*/
  IF VALID_YEAR &amp VALID_MONTH
     THEN DO;
       DAY_NUM = FIXED(DAY,15);

       /*--- ADJUST DAYS_IN_MONTH ARRAY FOR LEAP YEAR ---*/
       IF MONTH_NUM = 2
          THEN
            IF MOD(YEAR_NUM,4) = 0
               THEN DAYS_IN_MONTH(2) = 29;
               ELSE DAYS_IN_MONTH(2) = 28;

       IF DAY_NUM &lt 1
          THEN DO;
            VALID = '0'B;
            CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                 'INVALID DAY &quot' || DAY || '&quot IN DATETIME &quot' ||
<A NAME="VERIFY_VALUE_IS_IN_LIST"></A>                 STRING || '&quot.');
          END;
          ELSE
            IF DAY_NUM &gt DAYS_IN_MONTH(MONTH_NUM)
               THEN DO;
                 VALID = '0'B;
                 CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                 'INVALID DAY &quot' || DAY || '&quot IN DATETIME &quot' ||
                 STRING || '&quot.');
               END;

     END; /* IF VALID_YEAR &amp VALID_MONTH */


  /*--- IF AN ERROR HAS BEEN DETECTED, DO NOT CONTINUE. ---*/
  IF ^VALID
     THEN DO;
       STATUS = '0'B;
       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
       RETURN;
     END;


  /*--- AT THIS POINT, THE DATE AND TIME ARE VALID.  ASSEMBLE ---*/
  /*--- THEM INTO THE OUTPUT FORMAT.                          ---*/

  SELECT;

    WHEN (DIGITS_IN_OUTPUT_YEAR = 2)
      IF YEAR_NUM &gt 99
         THEN YEAR = SUBSTR(YEAR,LENGTH(YEAR)-1,2);

    WHEN (DIGITS_IN_OUTPUT_YEAR = 4)
      IF YEAR_NUM &lt 100
         THEN YEAR = '19' || YEAR;

    OTHERWISE
      CALL FATAL_ERROR ('PROGRAM',
           'UNSUPPORTED YEAR LENGTH (' ||
           TRIM(CHARACTER(DIGITS_IN_OUTPUT_YEAR)) ||
           ') IN OUTPUT FORMAT.');

  END; /* SELECT */


  /*--- ZERO-PAD THE VALUES IF APPROPRIATE FOR THIS FORMAT ---*/
  IF ZERO_PAD_MONTH &amp LENGTH(MONTH) &lt 2
     THEN MONTH = '0' || MONTH;

<A NAME="VERIFY_CODE_VALUE"></A>  IF ZERO_PAD_DAY &amp LENGTH(DAY) &lt 2
     THEN DAY = '0' || DAY;

  IF ZERO_PAD_HOUR &amp LENGTH(HOUR) &lt 2
     THEN HOUR = '0' || HOUR;

  IF ZERO_PAD_MINUTE &amp LENGTH(MINUTE) &lt 2
     THEN MINUTE = '0' || MINUTE;

  IF ZERO_PAD_SECOND &amp LENGTH(SECOND) &lt 2
     THEN SECOND = '0' || SECOND;


  /*--- NEW_FORMATS: EXTEND THIS SECTION FOR NEW FORMATS ---*/
  SELECT;
    WHEN (OUTPUT_FORMAT = 1)
      STRING = YEAR || MONTH || DAY;
    WHEN (OUTPUT_FORMAT = 2)
      STRING = YEAR || MONTH || DAY || HOUR || MINUTE || SECOND;
    WHEN (OUTPUT_FORMAT = 3)
      STRING = YEAR || MONTH || DAY || HOUR || MINUTE;
    OTHERWISE
      CALL FATAL_ERROR ('PROGRAM',
           'INVALID OUTPUT FORMAT (' ||
           TRIM(CHARACTER(OUTPUT_FORMAT)) ||
           ').');
  END;

  STATUS = '1'B;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;



 /*------------------------------------------------------------------*/
 /*                   PARSE_TYPE_1_INPUT_DATETIME                    */
 /*                                                                  */
 /* THIS PROCEDURE PARSES A TYPE 1 (MM/DD/YY HH:MM:SS) DATETIME INTO */
 /* ITS COMPONENTS.                                                  */
 /*                                                                  */
 /* NOTE: THIS PROCEDURE IS INTERNAL TO VERIFY_DATETIME_VALUE.       */
 /*------------------------------------------------------------------*/

 PARSE_TYPE_1_INPUT_DATETIME: PROC (STRING,MONTH,DAY,YEAR,HOUR,MINUTE,
                                    SECOND,INPUT_CONTAINS_TIME,
<A NAME="PARSE_CSV_RECORD"></A>                                    VALID,MESSAGE_LIST_PTR);

   DCL (STRING,MONTH,DAY,YEAR,HOUR,MINUTE,SECOND)  CHAR(*) VARYING,
       (INPUT_CONTAINS_TIME,VALID)                         BIT(1),
       MESSAGE_LIST_PTR                                    POINTER;

   DCL WORK_STRING        CHAR(512) VARYING,
       TOKEN              CHAR(512) VARYING,
       SAVE_SEGMENT       CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PARSE_TYPE_1_INPUT_DATETIME';

   MONTH  = '';
   DAY    = '';
   YEAR   = '';
   HOUR   = '';
   MINUTE = '';
   SECOND = '';


   /*--- IF STRING IS BLANK, RETURN BLANK VALUES ---*/
   IF STRING = ''
      THEN DO;
        INPUT_CONTAINS_TIME = '0'B;
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   WORK_STRING = TRIM(STRING);


   /*----------------------------------------------------------*/
   /*                PARSE THE MONTH, DAY AND YEAR             */
   /*----------------------------------------------------------*/

   /*--- EXTRACT THE MONTH ---*/
   CALL NEXT_TOKEN (WORK_STRING,'/',TOKEN);

   IF TOKEN = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   MONTH = TRIM(TOKEN);


   /*--- EXTRACT THE DAY ---*/
   IF WORK_STRING = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   CALL NEXT_TOKEN (WORK_STRING,'/',TOKEN);

   IF TOKEN = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   DAY = TRIM(TOKEN);


   /*--- EXTRACT THE YEAR ---*/
   IF WORK_STRING = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   CALL NEXT_TOKEN (WORK_STRING,' ',TOKEN);

   IF TOKEN = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

<A NAME="GET_QUOTED_FIELD"></A>   YEAR = TRIM(TOKEN);


   /*----------------------------------------------------------*/
   /*             PARSE THE HOUR, MINUTE, AND SECOND           */
   /*----------------------------------------------------------*/

   IF WORK_STRING = ''
      THEN DO;
        INPUT_CONTAINS_TIME  = '0'B;
        VALID                = '1'B;
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;


   /*--- EXTRACT THE HOUR ---*/
   CALL NEXT_TOKEN (WORK_STRING,':',TOKEN);

   IF TOKEN = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   HOUR = TRIM(TOKEN);

   /*--- EXTRACT THE MINUTE ---*/
   IF WORK_STRING = ''
      THEN DO;
        VALID = '0'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   CALL NEXT_TOKEN (WORK_STRING,':',TOKEN);

   IF TOKEN = ''
      THEN DO;
        SECOND = '00';
        VALID = '1'B;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
             'FORMAT OF DATETIME &quot' || STRING || '&quot IS INVALID.');
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN;
      END;

   MINUTE = TRIM(TOKEN);


   /*--- EXTRACT THE SECOND.  IF IT IS NOT THERE, DEFAULT TO 00  ---*/
   IF WORK_STRING ^= ''
      THEN SECOND = TRIM(WORK_STRING);
      ELSE SECOND = '00';

   INPUT_CONTAINS_TIME = '1'B;
   VALID               = '1'B;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END PARSE_TYPE_1_INPUT_DATETIME;



 /*------------------------------------------------------------------*/
 /*                         IS_INTEGER                               */
 /*                                                                  */
 /* THIS FUNCTION RETURNS TRUE IF THE STRING CONTAINS ONLY DIGITS.   */
 /* OTHERWISE, THE FUNCTION RETURNS FALSE.                           */
 /*                                                                  */
 /* NOTE: THIS PROCEDURE IS INTERNAL TO VERIFY_DATETIME_VALUE.       */
 /*------------------------------------------------------------------*/

 IS_INTEGER: PROC (STRING) RETURNS (BIT(1));

   DCL STRING         CHAR(*) VARYING,
       WORK_STRING    CHAR(512) VARYING,
       I              FIXED BIN (15),
       STRING_LENGTH  FIXED BIN (15),
       SAVE_SEGMENT   CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'IS_INTEGER';

   WORK_STRING = TRIM(STRING);

   STRING_LENGTH = LENGTH(WORK_STRING);

   IF STRING_LENGTH = 0
      THEN DO;
        SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
        RETURN ('0'B);
      END;

   DO I = 1 TO STRING_LENGTH;
      IF INDEX ( '0123456789', SUBSTR(WORK_STRING,I,1) ) = 0
         THEN DO;
           SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
           RETURN ('0'B);
         END;
   END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

   RETURN ('1'B);

 END IS_INTEGER;

 /*-------------------------------------------------------------------*/
 /*                             NEXT_TOKEN                            */
 /*                                                                   */
 /*  GIVEN A SEPARATOR CHARACTER, EXTRACT THE NEXT TOKEN FROM THE     */
 /*  SUPPLIED BUFFER.  THE TOKEN AND THE SEPARATOR WILL BE REMOVED    */
 /*  FROM THE BUFFER.                                                 */
 /*                                                                   */
 /*  WRITTEN BY : RTD  11/18/88                                       */
 /*                                                                   */
 /*-------------------------------------------------------------------*/
<A NAME="END_CSV_IMPORT"></A>
 NEXT_TOKEN: PROC (BUFFER,SEPARATOR,TOKEN);

  DCL BUFFER                 CHAR(*) VARYING,
      SEPARATOR              CHAR(*),
      TOKEN                  CHAR(*) VARYING,
      I                      FIXED BIN (15),
      LENGTH                 BUILTIN,
      SHELL$MODULE_SEGMENT   CHAR(31) EXTERNAL,
      SAVE_SEGMENT           CHAR(31);

  SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
  SHELL$MODULE_SEGMENT = 'NEXT_TOKEN';

  IF BUFFER = ''
     THEN DO;
       TOKEN = '';
       SHELL$MODULE_SEGMENT = SAVE_SEGMENT;
       RETURN;
     END;

  I = INDEX(BUFFER,SEPARATOR);

  SELECT;
     WHEN (I = 0)
       DO;
         TOKEN  = BUFFER;
         BUFFER = '';
       END;

     WHEN (I = 1)
       DO;
         TOKEN = '';
         IF LENGTH(BUFFER) = 1
            THEN BUFFER = '';
            ELSE BUFFER = SUBSTR(BUFFER,I+1);
       END;

    OTHERWISE
      DO;
       TOKEN  = SUBSTR(BUFFER,1,I-1);
       BUFFER = SUBSTR(BUFFER,I+1);
      END;
   END;

  SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END NEXT_TOKEN;

 END VERIFY_DATETIME_VALUE;

 /*------------------------------------------------------------*/
 /*          VERIFY_VALUE_IS_IN_LIST                           */
 /*------------------------------------------------------------*/
 VERIFY_VALUE_IS_IN_LIST:  PROC(STRING,VALUE_LIST_PTR,STATUS,
                                MESSAGE_LIST_PTR);

    DCL SAVE_SEGMENT                 CHAR (31),
        STRING                       CHAR (*) VARYING,
        VALUE_LIST_PTR               POINTER,
        STATUS                       BIT (1),
        MESSAGE_LIST_PTR             POINTER,
        TMP_PTR                      POINTER,
        VALUE_FOUND                  BIT (1) INIT ('0'B);

    DCL 1 VALUE_LIST_NODE            BASED,
          2 VALUE                    CHAR (80) VARYING,
          2 NEXT_PTR                 POINTER;


    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VERIFY_VALUE_IS_IN_LIST';

    STATUS = '1'B;

    TMP_PTR = VALUE_LIST_PTR;
    STRING = TRIM (STRING);


    DO WHILE (TMP_PTR ^= NULL &amp ^VALUE_FOUND);
       IF STRING = TMP_PTR-&gtVALUE_LIST_NODE.VALUE
         THEN VALUE_FOUND = '1'B;
         ELSE TMP_PTR = TMP_PTR-&gtVALUE_LIST_NODE.NEXT_PTR;
    END;


    IF ^VALUE_FOUND
      THEN DO;
        CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,
                  'THE VALUE IS NOT FOUND IN THE LIST OF VALUES');
        STATUS = '0'B;
      END;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END VERIFY_VALUE_IS_IN_LIST;

 /*-----------------------------------------------------------*/
 /*                   VERIFY_CODE_VALUE                       */
 /*                                                           */
 /* TPS: IF VALUE IS BLANK, TREAT AS IF IN CODE TABLE.        */
 /*-----------------------------------------------------------*/
 VERIFY_CODE_VALUE:  PROC (VALUE, TABLE, STATUS, MESSAGE_LIST_PTR);

   DCL SAVE_SEGMENT            CHAR (31),
       (VALUE,TABLE)           CHAR (*) VARYING,
       TABLE_NAME              CHAR (8),
       TABLE_VALUE             CHAR (8),
       (STATUS,CODETBLS_FOUND) BIT (1),
       MESSAGE                 CHAR (512) VARYING,
       CODETBLS_KEY            CHAR(16),
       MESSAGE_LIST_PTR        POINTER;

    SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
    SHELL$MODULE_SEGMENT = 'VERIFY_CODE_VALUE';

    TABLE_NAME  = TABLE;
    TABLE_VALUE = VALUE;

    CODETBLS_KEY   = TABLE_NAME || TABLE_VALUE;
    CODETBLS_FOUND = '1'B;
    ITRC = ITREAD ('CODETBLS',CODETBLS_KEY,'0','');
    IF ITRC ^= 0
       THEN CODETBLS_FOUND = '0'B;
       ELSE CODETBLS_FOUND = '1'B;

    IF ^CODETBLS_FOUND
       THEN DO;
         STATUS = '0'B;
         MESSAGE = 'CODE TABLE ENTRY NOT FOUND FOR TABLE=' ||
                  TRIM(TABLE) || ' VALUE=' || TRIM(VALUE);
         CALL ADD_MESSAGE_TO_MESSAGE_LIST (MESSAGE_LIST_PTR,MESSAGE);
       END;
       ELSE STATUS = '1'B;

    SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END VERIFY_CODE_VALUE;


 /*-------------------------------------------------------------------*/
 /*                          PARSE_CSV_RECORD                         */
 /*                                                                   */
 /* THIS PROCEDURE READS A FORMAT CSV LINE AND RETURNS THE FIELD      */
 /* CORRESPONDING TO THE FIELD NUMBER.  THIS PROCEDURE HANDLES THE    */
 /* EMBEDDING OF COMMAS WITHIN QUOTES, AND WILL STRIP OFF ANY LEADING */
 /* AND TRAILING DOUBLE QUOTE MARKS (&quot).  IT WILL ALSO TRANSFORM ALL  */
 /* DOUBLED QUOTE MARKS (&quot&quot) INTO A SINGLE DOUBLE QUOTE.  IF THERE    */
 /* IS NOT A FIELD COORESPONDING TO THE FIELD NUMBER SELECTED, OR THE */
 /* END OF THE CSV LILNE IS REACHED, AN ERROR IS RETURNED.            */
 /* THE PARSING IS AIDED BY PLACING AN ENDING COMMA AT THE END OF THE */
 /* LINE.                                                             */
 /*-------------------------------------------------------------------*/
 PARSE_CSV_RECORD: PROC (CSV_STRING,FIELD_NUM,FIELD,STATUS);

   DCL CSV_STRING        CHAR(*) VARYING,
       FIELD_NUM         FIXED BIN (15),
       FIELD             CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       TMP_STRING        CHAR (4096) VARYING,
       I                 FIXED BIN (15),     /* POSITIONAL       */
       L                 FIXED BIN (15),     /* LENGTH OF STRING */
       N                 FIXED BIN (15),     /* COUNT            */
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'PARSE_CSV_RECORD';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('FIELD NUM = ',FIELD_NUM);
       %END;

    STATUS = 0;
    FIELD = '';

   /* CHECK TO INSURE THAT THE STRING IS NOT BLANK */
   /* AND NOT  NULL, BEFORE CONTINUEING            */

    IF CSV_STRING = ' '
       THEN STATUS = 2;   /* BLANK STRING */

    IF LENGTH(CSV_STRING) = 0
       THEN STATUS = 4;   /* NULL STRING */

  /* CHECK FOR A COMMA */

    IF STATUS = 0
       THEN DO;
        I = INDEX (CSV_STRING,',');
        IF I = 0
           THEN STATUS =  6;  /* NOT A CSV STRING */
       END;

    TMP_STRING = CSV_STRING || ',';
    N          =  0;

    DO WHILE (STATUS = 0 &amp
              N &lt FIELD_NUM);

        IF I = 0
           THEN DO;
            STATUS = 10;  /* FIELD NOT FOUND */
            FIELD = '';
           END;
           ELSE DO;
            FIELD = ' ';
            L          = LENGTH(TMP_STRING);
            FIELD      = SUBSTR(TMP_STRING,1,I-1);
            TMP_STRING = SUBSTR(TMP_STRING,I);

            IF INDEX (FIELD,'&quot') &gt 0
                THEN DO;
                  CALL GET_QUOTED_FIELD (TMP_STRING,FIELD,STATUS);
                END;
            N = N +1;
            TMP_STRING = SUBSTR(TMP_STRING,2);
            I = INDEX (TMP_STRING,',');
          END; /* OF ELSE */

      END; /* OF WHILE */

    IF FIELD = ''
       THEN FIELD = ' ';
  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
          PUT SKIP LIST ('FIELD = ',TRIM(FIELD));
          PUT SKIP LIST ('STATUS = ',STATUS);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 /*-------------------------------------------------------------------*/
 /*                          GET_QUOTED_FIELD                         */
 /*                                                                   */
 /* THIS PROCEDURE READS A QUOTED FIELD FROM A CSV STRING.            */
 /*                                                                   */
 /* IMPORTANT:                                                        */
 /* THE QUOTED STRING WILL ALWAYS CONTAIN AN EVEN NUMBER OF DOUBLE    */
 /* QUOTE MARKS (&quot).  IT WILL ALWAYS END AT A COMMA.  THESE TWO       */
 /* ASSUMPTIONS ARE IMPORTANT, SINCE THEY FORM THE BASIS FOR THE      */
 /* LOGIC WITHIN THE PROCEDURE.                                       */
 /* ONCE THE QUOTED FIELD IS DETERMINE, THE LAST STEP IS TO STRIP OFF */
 /* DOUBLE QUOTATION MARKS.  THIS IS DONE BY WALKING THE FIELD AND IF */
 /* A DOUBLE QUOTE IS ENCOUNTERED, THEN THIS CHARACTER IS SKIPPED.    */
 /*-------------------------------------------------------------------*/
 GET_QUOTED_FIELD: PROC (CSV_STRING,FIELD,STATUS);

   DCL CSV_STRING        CHAR(*) VARYING,
       FIELD             CHAR (*) VARYING,
       STATUS            FIXED BIN (15),
       TMP_STRING        CHAR (4096) VARYING,
       I                 FIXED BIN (15),     /* POSITIONAL       */
       P                 FIXED BIN (15),     /* POSITIONAL       */
       L                 FIXED BIN (15),     /* LENGTH OF STRING */
       QCNT              FIXED BIN (15),     /* NO. OF '&quot'       */
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'GET_QUOTED_FIELD';

  /* COUNT THE DOUBLE QUOTES WITHIN FIELD */
  /* FIRST.                               */

   L = LENGTH(FIELD);
   P = 1;
   QCNT = 0;

   DO WHILE (P &lt= L);
      IF SUBSTR(FIELD,P,1) = '&quot'
         THEN QCNT = QCNT + 1;
      P = P + 1;
   END;  /* COUNT '&quot' */

   DO WHILE ((MOD(QCNT,2) ^= 0) &amp
             (STATUS = 0));

     IF LENGTH(CSV_STRING) = 0
        THEN STATUS = 12;        /* UNBALANCE QUOTES */
        ELSE DO;

         /* NEED TO INCREMENT CSV_STRING BY ONE TO TEMPORARILY */
         /* SKIP THE ','.  THIS ',' WILL BECOME PART OF THE    */
         /* QUOTED FIELD.                                      */

         L          = LENGTH (CSV_STRING);
         TMP_STRING = SUBSTR (CSV_STRING,2);

         /* NOW FIND THE NEXT ','.  ALL FIELDS ARE DELIMINATED */
         /* BY A ',', EVEN QUOTED FIELDS.                      */

         I          = INDEX (TMP_STRING,',');
         IF I = 0
            THEN STATUS = 12;        /* UNBALANCE QUOTES */
            ELSE DO;

         /* TEMPORARILY SAVE THE NEXT PART OF THE QUOTED STRING */
         /* SO A COUNT OF THE '&quot' CAN BE MADE.  THEN APPEND IT  */
         /* TO THE FIELD.                                       */

             TMP_STRING = SUBSTR (CSV_STRING,1,I);
             L          = LENGTH(TMP_STRING);
             P          = 1;
             DO WHILE (P &lt= L);
                 IF SUBSTR(TMP_STRING,P,1) = '&quot'
                    THEN QCNT = QCNT + 1;
                 P = P + 1;
             END;  /* COUNT '&quot' */

             FIELD      = FIELD || TMP_STRING;

             CSV_STRING = SUBSTR (CSV_STRING,I+1);

           END; /* IF COMMA NOT FOUOND */

        END; /* IF CSV_STRING NOT BLANK */

    END; /* WHILE QUOTED STRING NOT FINISHED. */

  /* AT THIS POINT, WE SHOULD HAVE THE FIELD */
  /* WE NOW NEED TO STRIP OFF THE '&quot'        */

  L          = LENGTH (FIELD);
  TMP_STRING = SUBSTR (FIELD,2,L-1);
  TMP_STRING = SUBSTR (TMP_STRING,1,L-2);

  /* NOW LETS CONVERT ANY '&quot&quot' INTO '&quot' */
  FIELD = '';

  L = LENGTH (TMP_STRING);
  I = 1;
  DO WHILE (I&lt=L);
    IF SUBSTR (TMP_STRING,I,1) = '&quot'
       THEN I = I + 1;
    FIELD = FIELD || SUBSTR (TMP_STRING,I,1);
    I = I + 1;
  END;

 SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END  GET_QUOTED_FIELD;

 END PARSE_CSV_RECORD;


 /*------------------------------------------------------------------*/
 /*                         END_CSV_IMPORT                           */
 /*                                                                  */
 /* THIS PROCEDURE TRAVERSES THE IMPORT DEFINITION FIELD LIST AND    */
 /* CLOSES ALL TABLES SPECIFIED IN THE NODE.                         */
 /*                                                                  */
 /* PARAMETERS:                                                      */
 /*   IDSPTR       - POINTER TO THE IMPORT_DEFINITION STRUCTURE.     */
 /*                                                                  */
 /*   STATUS       - FIXED BIN (15) STATUS OF THE INITIALIZATION     */
 /*                  PROCESS.                                        */
 /*                  0 - SUCCESSFUL                                  */
 /*                 12 - FAILED.                                     */
 /*                                                                  */
 /*     ERRLST_TOP - POINTER TO LIST OF ERROR MESSAGE STRINGS.       */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*  AUTHOR: TPS                                                     */
 /*  DATE:   2/26/95                                                 */
 /*                                                                  */
 /*  MODIFICATIONS:                                                  */
 /*                                                                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 END_CSV_IMPORT: PROC (IDSPTR,STATUS,ERRLST_TOP);
   DCL IDSPTR            POINTER,
       STATUS            FIXED BIN (15),
       ERRLST_TOP        POINTER,

       IDR_PTR           POINTER,
       CODETBLS_OPEN     BIT (1),
       ERRMSG            CHAR (512) VARYING,
       SAVE_SEGMENT      CHAR(31);

   SAVE_SEGMENT = SHELL$MODULE_SEGMENT;
   SHELL$MODULE_SEGMENT = 'END_CSV_IMPORT';

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('INSIDE OF ',SHELL$MODULE_SEGMENT);
       %END;

   STATUS = 0;

   IDR_PTR = IDSPTR-&gtIMPORT_DEFINITION.RECORD_LIST_PTR;
   IF IDR_PTR = NULL
      THEN DO;
        STATUS = 12;
        ERRMSG = 'CANNOT CLOSE FILES, NULL POINTER RECEIVED';
        CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                         ERRMSG    );
      END;

   CODETBLS_OPEN = '1'B;

   DO WHILE (IDR_PTR ^= NULL);

      IF IDR_PTR-&gtRECORD_NODE.TABLE_OPEN
          THEN DO;
           ITRC = ITCLOSE (TRIM(IDR_PTR-&gtRECORD_NODE.TABLE),' ');
           IDR_PTR-&gtRECORD_NODE.TABLE_OPEN = '0'B;

           IF ITRC ^= 0
              THEN DO;
                STATUS = 16;
                ERRMSG = 'ERROR ENCOUNTERED WHILE CLOSING FILE ' ||
                         TRIM(IDR_PTR-&gtRECORD_NODE.TABLE)        ||
                         '.  IT RETURN CODE: ' || TRIM(CHAR(ITRC));
                CALL ADD_MESSAGE_TO_MESSAGE_LIST(ERRLST_TOP,
                                                 ERRMSG    );
              END;

           IF TRIM (IDR_PTR-&gtRECORD_NODE.TABLE) = 'CODETBLS'
              THEN CODETBLS_OPEN = '0'B;
          END;

      IDR_PTR = IDR_PTR-&gtRECORD_NODE.NEXT_PTR;

   END;

   /* CLOSE THE CODE TABLES FILE */

   IF CODETBLS_OPEN
      THEN ITRC = ITCLOSE ('CODETBLS',' ');

  %IF DEBUGGER = 'ON'
       %THEN %DO;
          PUT SKIP LIST ('LEAVING ',SHELL$MODULE_SEGMENT);
       %END;

   SHELL$MODULE_SEGMENT = SAVE_SEGMENT;

 END END_CSV_IMPORT;

 END <A HREF="cfbimpt.htm#CFBIMPT">CFBIMPT</A>;
</PRE>
<ONLINE>
<HR>
<A HREF="ebsindex.htm"><IMG SRC="/clipart/back.gif" ALIGN="MIDDLE" BORDER=0>
EBSIndex</A><P>
<A HREF="/index.htm"><IMG SRC="/clipart/home.gif" ALIGN="MIDDLE" BORDER=0>
Network Home Page</A>
<HR>
<EM>
Please send any comments or problems to
<A HREF="mailto:webmasterTE_ENTITY_NODECFBIMPTCFBIMPTCROCUPDATE_ENTITY_NODECsePROCESS_SITESC.com">webmasterTE_ENTITY_NODECFBIMPTCFBIMPTCROCUPDATE_ENTITY_NODECsePROCESS_SITESC.com</A>
</EM>
</ONLINE>
</BODY>
</HTML>

